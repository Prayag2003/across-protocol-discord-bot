{
    "https://docs.across.to/developer-docs": {
        "title": "Overview | Across Docs",
        "headers": [
            "Overview",
            "Resources to learn more"
        ],
        "paragraphs": [
            "Below is an overview of how a bridge transfer on Across works from start to finish.",
            "Last updated 8 months ago",
            "A user that would like to move funds from chain A to chain B deposits funds into a Spoke Pool on chain A with instructions about where they would like their funds to wind up and the fee that they are willing to pay.",
            "Relayers view these deposits and, once they have verified that the details of the deposit are correct, immediately provide funds to the user on chain B. The user is now satisfied, having received their funds minus any fees and no longer needs to interact with Across.",
            "After the relayer has performed the relay, a proof of that relay and the validity of the original deposit is submitted to the optimistic oracle (OO) and the relayer is reimbursed once this information has been verified by the OO.",
            "The relayer's reimbursement is taken out of a single liquidity pool on Ethereum Mainnet escrowed in a contract called the Hub Pool. Liquidity providers (\"LP's\") to this pool also earn a fee per transfer that is assessed on the user's deposited amount.",
            "The rules for how funds are moved between the L2 Spoke Pools and the L1 Hub Pool to reimburse relayers are explained in UMIP-157. Anyone who wants to move funds between the pools must submit a valid proof to the OO that abides by the rules explained in the UMIP.",
            "To see how this all comes together, check out the chart below showing a complete end-to-end flow of the process.",
            "The smart contract code can be found here, including implementations of the HubPool and SpokePool.",
            "The smart contracts were audited by OpenZeppelin. The audit report contains a high-level summary of how the smart contract architecture works.",
            "Moreover, here is a 60-minute explainer video of the smart contract architecture. Slides for the explainer video can be found here."
        ],
        "lists": [
            "How Across Works\nOverview\nRoles within Across\nFee Model\nValidating Root Bundles\nDisputing Root Bundles\nDevelopers\nAcross API\nAcross SDK\nContract Addresses\nMainnet (Chain ID: 1)\nArbitrum (Chain ID: 42161)\nOptimism (Chain ID: 10)\nBase (Chain ID: 8453)\nzkSync (Chain ID: 324)\nPolygon (Chain ID: 137)\nSelected Contract Functions\nRunning a Relayer\nIntegrating Across into your application\nComposable Bridging\nDeveloper notes\nMigration from V2 to V3\nADDITIONAL INFO\nSupport Links\nBug Bounty\nAudits",
            "Overview\nRoles within Across\nFee Model\nValidating Root Bundles\nDisputing Root Bundles",
            "Roles within Across\nFee Model\nValidating Root Bundles\nDisputing Root Bundles",
            "Across API\nAcross SDK\nContract Addresses\nMainnet (Chain ID: 1)\nArbitrum (Chain ID: 42161)\nOptimism (Chain ID: 10)\nBase (Chain ID: 8453)\nzkSync (Chain ID: 324)\nPolygon (Chain ID: 137)\nSelected Contract Functions\nRunning a Relayer\nIntegrating Across into your application\nComposable Bridging\nDeveloper notes\nMigration from V2 to V3",
            "Mainnet (Chain ID: 1)\nArbitrum (Chain ID: 42161)\nOptimism (Chain ID: 10)\nBase (Chain ID: 8453)\nzkSync (Chain ID: 324)\nPolygon (Chain ID: 137)",
            "Support Links\nBug Bounty\nAudits"
        ],
        "tables": [],
        "code_blocks": [],
        "summaries": []
    },
    "https://docs.across.to/?fallback=true": {
        "title": "Getting Started | Across Docs",
        "headers": [
            "Getting Started",
            "Looking for something else? Get in touch"
        ],
        "paragraphs": [
            "Last updated 2 months ago",
            "Across is an interoperability protocol powered by intents. It is the first cross-chain intents protocol in production today, enabling the fastest and lowest-cost way to transfer value without security tradeoffs.",
            "Across can be easily integrated via our easy to use REST API into any application requiring instant, low cost cross-chain value transfer. Let users easily onboard assets without leaving your app. ",
            "Across can also be integrated in your application to abstract bridging completely, enabling users to directly interact with your app from any chain. ",
            "Across Settlement is the only production-ready, modular settlement layer built to facilitate cross-chain intents. Powers use cases that require customization beyond the Across Core offering, like cross-chain token swaps, new request for quote auction designs and more. ",
            "Join the growing network of independent relayers (a.k.a solvers, fillers, market makers) fulfilling intent order flow on Across. Earn up to 100% APY. ",
            ""
        ],
        "lists": [
            "üëã\nIntroduction\nGetting Started\nWhat is Across?\nTechnical FAQ\nMigration Guides\nMigration from V2 to V3\nMigration to CCTP\nMigration Guide for Relayers\nMigration Guide for API Users\nüîó\nUse Cases\nInstant Bridging in your Application\nBridge Integration Guide\nMulti Chain Bridge UI Guide\nSingle Chain Bridge UI Guide\nEmbedded Cross-chain Actions\nCross-chain Actions Integration Guide\nUsing the Generic Multicaller Handler Contract\nUsing a Custom Handler Contract\nCross-chain Actions UI Guide\nSettle Cross-chain Intents\nüß†\nConcepts\nWhat are Cross-chain Intents?\nIntents Architecture in Across\nIntent Lifecycle in Across\nCanonical Asset Maximalism\nüõ†Ô∏è\nReference\nAPI Reference\nSDK Reference\nContracts\nArbitrum (Chain ID: 42161)\nBase (Chain ID: 8453)\nBlast (Chain ID: 81457)\nEthereum Mainnet (Chain ID: 1)\nLinea (Chain ID: 59144)\nLisk (Chain ID: 1135)\nMode (Chain ID: 34443)\nOptimism (Chain ID: 10)\nPolygon (Chain ID: 137)\nRedstone (Chain ID: 690)\nScroll (Chain ID: 534352)\nWorld Chain (Chain ID: 480)\nzkSync (Chain ID: 324)\nZora (Chain ID: 7777777)\nSepolia Testnet\nSelected Contract Functions\nSupported Chains\nFees in the System\nActors in the System\nSecurity Model and Verification\nDisputing Root Bundles\nValidating Root Bundles\nTracking Events\nüîÅ\nRelayers\nRunning a Relayer\nRelayer Exclusivity\nüìö\nResources\nRelease Notes\nDeveloper Support\nBug Bounty\nAudits\nNew Chain Requests",
            "Getting Started\nWhat is Across?\nTechnical FAQ\nMigration Guides\nMigration from V2 to V3\nMigration to CCTP\nMigration Guide for Relayers\nMigration Guide for API Users",
            "Migration from V2 to V3\nMigration to CCTP\nMigration Guide for Relayers\nMigration Guide for API Users",
            "Migration Guide for Relayers\nMigration Guide for API Users",
            "Instant Bridging in your Application\nBridge Integration Guide\nMulti Chain Bridge UI Guide\nSingle Chain Bridge UI Guide\nEmbedded Cross-chain Actions\nCross-chain Actions Integration Guide\nUsing the Generic Multicaller Handler Contract\nUsing a Custom Handler Contract\nCross-chain Actions UI Guide\nSettle Cross-chain Intents",
            "Bridge Integration Guide\nMulti Chain Bridge UI Guide\nSingle Chain Bridge UI Guide",
            "Cross-chain Actions Integration Guide\nUsing the Generic Multicaller Handler Contract\nUsing a Custom Handler Contract\nCross-chain Actions UI Guide",
            "Using the Generic Multicaller Handler Contract\nUsing a Custom Handler Contract",
            "What are Cross-chain Intents?\nIntents Architecture in Across\nIntent Lifecycle in Across\nCanonical Asset Maximalism",
            "API Reference\nSDK Reference\nContracts\nArbitrum (Chain ID: 42161)\nBase (Chain ID: 8453)\nBlast (Chain ID: 81457)\nEthereum Mainnet (Chain ID: 1)\nLinea (Chain ID: 59144)\nLisk (Chain ID: 1135)\nMode (Chain ID: 34443)\nOptimism (Chain ID: 10)\nPolygon (Chain ID: 137)\nRedstone (Chain ID: 690)\nScroll (Chain ID: 534352)\nWorld Chain (Chain ID: 480)\nzkSync (Chain ID: 324)\nZora (Chain ID: 7777777)\nSepolia Testnet\nSelected Contract Functions\nSupported Chains\nFees in the System\nActors in the System\nSecurity Model and Verification\nDisputing Root Bundles\nValidating Root Bundles\nTracking Events",
            "Arbitrum (Chain ID: 42161)\nBase (Chain ID: 8453)\nBlast (Chain ID: 81457)\nEthereum Mainnet (Chain ID: 1)\nLinea (Chain ID: 59144)\nLisk (Chain ID: 1135)\nMode (Chain ID: 34443)\nOptimism (Chain ID: 10)\nPolygon (Chain ID: 137)\nRedstone (Chain ID: 690)\nScroll (Chain ID: 534352)\nWorld Chain (Chain ID: 480)\nzkSync (Chain ID: 324)\nZora (Chain ID: 7777777)\nSepolia Testnet",
            "Disputing Root Bundles\nValidating Root Bundles",
            "Running a Relayer\nRelayer Exclusivity",
            "Release Notes\nDeveloper Support\nBug Bounty\nAudits\nNew Chain Requests"
        ],
        "tables": [],
        "code_blocks": [],
        "summaries": []
    },
    "https://docs.across.to/developer-docs?fallback=true": {
        "title": "Overview | Across Docs",
        "headers": [
            "Overview",
            "Resources to learn more"
        ],
        "paragraphs": [
            "Below is an overview of how a bridge transfer on Across works from start to finish.",
            "Last updated 8 months ago",
            "A user that would like to move funds from chain A to chain B deposits funds into a Spoke Pool on chain A with instructions about where they would like their funds to wind up and the fee that they are willing to pay.",
            "Relayers view these deposits and, once they have verified that the details of the deposit are correct, immediately provide funds to the user on chain B. The user is now satisfied, having received their funds minus any fees and no longer needs to interact with Across.",
            "After the relayer has performed the relay, a proof of that relay and the validity of the original deposit is submitted to the optimistic oracle (OO) and the relayer is reimbursed once this information has been verified by the OO.",
            "The relayer's reimbursement is taken out of a single liquidity pool on Ethereum Mainnet escrowed in a contract called the Hub Pool. Liquidity providers (\"LP's\") to this pool also earn a fee per transfer that is assessed on the user's deposited amount.",
            "The rules for how funds are moved between the L2 Spoke Pools and the L1 Hub Pool to reimburse relayers are explained in UMIP-157. Anyone who wants to move funds between the pools must submit a valid proof to the OO that abides by the rules explained in the UMIP.",
            "To see how this all comes together, check out the chart below showing a complete end-to-end flow of the process.",
            "The smart contract code can be found here, including implementations of the HubPool and SpokePool.",
            "The smart contracts were audited by OpenZeppelin. The audit report contains a high-level summary of how the smart contract architecture works.",
            "Moreover, here is a 60-minute explainer video of the smart contract architecture. Slides for the explainer video can be found here."
        ],
        "lists": [
            "How Across Works\nOverview\nRoles within Across\nFee Model\nValidating Root Bundles\nDisputing Root Bundles\nDevelopers\nAcross API\nAcross SDK\nContract Addresses\nMainnet (Chain ID: 1)\nArbitrum (Chain ID: 42161)\nOptimism (Chain ID: 10)\nBase (Chain ID: 8453)\nzkSync (Chain ID: 324)\nPolygon (Chain ID: 137)\nSelected Contract Functions\nRunning a Relayer\nIntegrating Across into your application\nComposable Bridging\nDeveloper notes\nMigration from V2 to V3\nADDITIONAL INFO\nSupport Links\nBug Bounty\nAudits",
            "Overview\nRoles within Across\nFee Model\nValidating Root Bundles\nDisputing Root Bundles",
            "Roles within Across\nFee Model\nValidating Root Bundles\nDisputing Root Bundles",
            "Across API\nAcross SDK\nContract Addresses\nMainnet (Chain ID: 1)\nArbitrum (Chain ID: 42161)\nOptimism (Chain ID: 10)\nBase (Chain ID: 8453)\nzkSync (Chain ID: 324)\nPolygon (Chain ID: 137)\nSelected Contract Functions\nRunning a Relayer\nIntegrating Across into your application\nComposable Bridging\nDeveloper notes\nMigration from V2 to V3",
            "Mainnet (Chain ID: 1)\nArbitrum (Chain ID: 42161)\nOptimism (Chain ID: 10)\nBase (Chain ID: 8453)\nzkSync (Chain ID: 324)\nPolygon (Chain ID: 137)",
            "Support Links\nBug Bounty\nAudits"
        ],
        "tables": [],
        "code_blocks": [],
        "summaries": []
    },
    "https://docs.across.to/user-docs?fallback=true": {
        "title": "About | Across Docs",
        "headers": [
            "About"
        ],
        "paragraphs": [
            "Interoperability Powered by Intents",
            "Across is an interoperability protocol powered by intents. It is the only cross-chain intents protocol in production today, enabling the fastest and lowest-cost interoperability solution without security tradeoffs.\n\nAcross Protocol is comprised of three products.",
            "The Across Bridge, the most capital efficient cross-chain transfer solution for end users. Across' intents-based framework has proven to facilitate the fastest and cheapest bridging between L2s and Mainnet.",
            "Across+, is a chain abstraction tool that utilizes cross-chain bridge hooks to fulfill user intents. Across+ allows developers to integrate bridge + action(s) bundles at the dapp level to promote onboarding and abstract the bridging process away from end users.",
            "Across Settlement, is a settlement layer for all cross-chain intent order flow. Its optimistic design, which defers verification, focuses on gas optimization to significantly reduce cross-chain settlement costs for protocols and, ultimately, end users.",
            "As the multichain economy continues to evolve, intents-based settlement is the key to solving interoperability and Across is at the core of its execution.",
            "Last updated 6 months ago"
        ],
        "lists": [
            "How to Use Across\nAbout\nBridging\nProviding Bridge Liquidity\nProtocol Rewards\nReward Locking\nTransaction History\nHow across works\nOverview\nSecurity\nFees\nSpeed\nSupported Chains and Tokens\nü™ô\n$ACX Token\nToken Overview\nInitial Allocations\nACX Emissions Committee\nGovernance\nGovernance Model\nProposals and Voting\nAdditional Info\nFAQ\nSupport Links\nMigrating from V1\nAcross Brand Assets",
            "About\nBridging\nProviding Bridge Liquidity\nProtocol Rewards\nReward Locking\nTransaction History",
            "Reward Locking",
            "Overview\nSecurity\nFees\nSpeed\nSupported Chains and Tokens",
            "Token Overview\nInitial Allocations\nACX Emissions Committee",
            "Governance Model\nProposals and Voting",
            "FAQ\nSupport Links\nMigrating from V1\nAcross Brand Assets"
        ],
        "tables": [],
        "code_blocks": [],
        "summaries": []
    },
    "https://docs.across.to/developer-docs/how-across-works/readme/roles-within-across": {
        "title": "Roles within Across | Across Docs",
        "headers": [
            "Roles within Across",
            "User",
            "Liquidity Provider",
            "Relayer ",
            "Dataworker"
        ],
        "paragraphs": [
            "Describing key roles within the Across system.",
            "A user is someone who bridges assets between L2s and L1 with Across. Users pay relayers and liquidity providers in order to send their tokens instantly across networks that support their token. You can find the step by step for users here. ",
            "A liquidity provider or LP is an actor who deposits assets into one of the pools on Across.to/pool. Liquidity Providers insure user funds in exchange for fees. You can find the step-by-step process for liquidity providers here. ",
            "Relayers give out short-term token loans to Users in exchange for fees. Relayers fulfill deposit requests by sending the depositor their desired token on their requested ‚Äúdestination chain‚Äù. Relayers will send the recipient the full deposit amount minus a relayer fee, meaning that they will keep the relayer fee as an incentive for crediting the depositor funds. You can read up on running a relayer here. ",
            "Dataworkers support the stability and healthy functioning of the system by refunding relayers and moving system assets between networks.",
            "",
            "Last updated 1 year ago"
        ],
        "lists": [
            "How Across Works\nOverview\nRoles within Across\nFee Model\nValidating Root Bundles\nDisputing Root Bundles\nDevelopers\nAcross API\nAcross SDK\nContract Addresses\nMainnet (Chain ID: 1)\nArbitrum (Chain ID: 42161)\nOptimism (Chain ID: 10)\nBase (Chain ID: 8453)\nzkSync (Chain ID: 324)\nPolygon (Chain ID: 137)\nSelected Contract Functions\nRunning a Relayer\nIntegrating Across into your application\nComposable Bridging\nDeveloper notes\nMigration from V2 to V3\nADDITIONAL INFO\nSupport Links\nBug Bounty\nAudits",
            "Overview\nRoles within Across\nFee Model\nValidating Root Bundles\nDisputing Root Bundles",
            "Roles within Across\nFee Model\nValidating Root Bundles\nDisputing Root Bundles",
            "Across API\nAcross SDK\nContract Addresses\nMainnet (Chain ID: 1)\nArbitrum (Chain ID: 42161)\nOptimism (Chain ID: 10)\nBase (Chain ID: 8453)\nzkSync (Chain ID: 324)\nPolygon (Chain ID: 137)\nSelected Contract Functions\nRunning a Relayer\nIntegrating Across into your application\nComposable Bridging\nDeveloper notes\nMigration from V2 to V3",
            "Mainnet (Chain ID: 1)\nArbitrum (Chain ID: 42161)\nOptimism (Chain ID: 10)\nBase (Chain ID: 8453)\nzkSync (Chain ID: 324)\nPolygon (Chain ID: 137)",
            "Support Links\nBug Bounty\nAudits",
            "User\nLiquidity Provider\nRelayer \nDataworker"
        ],
        "tables": [],
        "code_blocks": [],
        "summaries": []
    },
    "https://docs.across.to/developer-docs/how-across-works/readme/fee-model": {
        "title": "Fee Model | Across Docs",
        "headers": [
            "Fee Model",
            "Liquidity Provider Fees",
            "Relayer Fees"
        ],
        "paragraphs": [
            "We view using Across as being similar to lending protocols such as AAVE or Compound. When a user bridges a particular token from one chain to another, the fast bridge isn't \"moving tokens from one chain to another\" but, rather, it is a relayer or the protocol itself providing tokens on the destination chain in return for tokens on the origin chain. We choose to use a similar pricing model for our liquidity provider fees because of this parallel.",
            "We base our pricing model on the one described in AAVE's documentation. Let,",
            "XXXdenote the size of a particular transaction someone is seeking to bridge",
            "0‚â§Ut‚â§10 \\leq U_t \\leq 10‚â§Ut‚Äã‚â§1denote the utilization of the liquidity providers' capital prior to the transaction, i.e. the amount of the liquidity providers' capital that is in use prior to the current transaction",
            "0‚â§U^t‚â§10 \\leq \\hat{U}_t \\leq 10‚â§U^t‚Äã‚â§1denote the utilization of the liquidity providers' capital after to the transaction, i.e. the amount of the liquidity providers' capital that would be in use if the user chose to execute their transaction",
            "UÀâ\\bar{U}UÀâdenote the \"kink utilization\" where the slope on the interest rate changes",
            "R0,R1,R2R_0, R_1, R_2R0‚Äã,R1‚Äã,R2‚Äãdenote the parameters governing the interest rate model slopes",
            "R0R_0R0‚Äãis the interest rate that would be charged at 0% utilization",
            "R0+R1R_0 + R_1R0‚Äã+R1‚Äãis the interest rate that would be charged at UÀâ%\\bar{U}\\% UÀâ%utilization",
            "R0+R1+R2R_0 + R_1 + R_2R0‚Äã+R1‚Äã+R2‚Äãis the interest rate that would be charged at 100% utilization",
            "The (annualized) interest rate model is then defined by",
            "We calculate the (annualized) interest rate for a particular loan by aggregating the marginal increases of utilization by integrating over this function",
            "The actual fee that is charged will be based on making a loan at this rate for a 1 week time-span. The rate that is charged can be computed from:",
            "and the fee would be",
            "",
            "This might seem like a lot that you are required to understand, but when you are interacting with the bridge, these details will mostly be hidden from you and you will just see a value for the \"liquidity provider fee\".",
            "We chose to charge prices this way to ensure that users are paying a \"fair\" price for the amount of utilization that their bridge transaction incurs.",
            "Relayer fees play a similar role in the Across ecosystem as gas fees play in the Ethereum ecosystem. Relayer fees are a fee that the user sets to incentivize relayers to relay your bridge transaction.",
            "Relaying a transaction has three costs for relayers:",
            "Gas fees: The relayer pays gas to perform the relay and to claim their repayment.",
            "Capital opportunity costs: The fact that the relayer is using their capital to perform a relay means that they are not using it for other yield opportunities.",
            "Capital at risk: A relayer takes on certain risks by relaying funds. If they make a mistake when relaying that could jeopardize their repayment of the capital they invested.",
            "These fees are automatically set by the front-end but could also be set manually by interacting with the contract directly. If you set them manually, make sure to set them high enough so that a relayer would be willing to relay your transactions.",
            "",
            "",
            "Last updated 11 months ago"
        ],
        "lists": [
            "How Across Works\nOverview\nRoles within Across\nFee Model\nValidating Root Bundles\nDisputing Root Bundles\nDevelopers\nAcross API\nAcross SDK\nContract Addresses\nMainnet (Chain ID: 1)\nArbitrum (Chain ID: 42161)\nOptimism (Chain ID: 10)\nBase (Chain ID: 8453)\nzkSync (Chain ID: 324)\nPolygon (Chain ID: 137)\nSelected Contract Functions\nRunning a Relayer\nIntegrating Across into your application\nComposable Bridging\nDeveloper notes\nMigration from V2 to V3\nADDITIONAL INFO\nSupport Links\nBug Bounty\nAudits",
            "Overview\nRoles within Across\nFee Model\nValidating Root Bundles\nDisputing Root Bundles",
            "Roles within Across\nFee Model\nValidating Root Bundles\nDisputing Root Bundles",
            "Across API\nAcross SDK\nContract Addresses\nMainnet (Chain ID: 1)\nArbitrum (Chain ID: 42161)\nOptimism (Chain ID: 10)\nBase (Chain ID: 8453)\nzkSync (Chain ID: 324)\nPolygon (Chain ID: 137)\nSelected Contract Functions\nRunning a Relayer\nIntegrating Across into your application\nComposable Bridging\nDeveloper notes\nMigration from V2 to V3",
            "Mainnet (Chain ID: 1)\nArbitrum (Chain ID: 42161)\nOptimism (Chain ID: 10)\nBase (Chain ID: 8453)\nzkSync (Chain ID: 324)\nPolygon (Chain ID: 137)",
            "Support Links\nBug Bounty\nAudits",
            "Liquidity Provider Fees\nRelayer Fees",
            "X\nX\nX\ndenote the size of a particular transaction someone is seeking to bridge\n0\n‚â§\nU\nt\n‚â§\n1\n0 \\leq U_t \\leq 1\n0\n‚â§\nU\nt\n‚Äã\n‚â§\n1\ndenote the utilization of the liquidity providers' capital prior to the transaction, i.e. the amount of the liquidity providers' capital that is in use prior to the current transaction\n0\n‚â§\nU\n^\nt\n‚â§\n1\n0 \\leq \\hat{U}_t \\leq 1\n0\n‚â§\nU\n^\nt\n‚Äã\n‚â§\n1\ndenote the utilization of the liquidity providers' capital after to the transaction, i.e. the amount of the liquidity providers' capital that would be in use if the user chose to execute their transaction\nU\nÀâ\n\\bar{U}\nU\nÀâ\ndenote the \"kink utilization\" where the slope on the interest rate changes\nR\n0\n,\nR\n1\n,\nR\n2\nR_0, R_1, R_2\nR\n0\n‚Äã\n,\nR\n1\n‚Äã\n,\nR\n2\n‚Äã\ndenote the parameters governing the interest rate model slopes\nR\n0\nR_0\nR\n0\n‚Äã\nis the interest rate that would be charged at 0% utilization\nR\n0\n+\nR\n1\nR_0 + R_1\nR\n0\n‚Äã\n+\nR\n1\n‚Äã\nis the interest rate that would be charged at \nU\nÀâ\n%\n\\bar{U}\\% \nU\nÀâ\n%\nutilization\nR\n0\n+\nR\n1\n+\nR\n2\nR_0 + R_1 + R_2\nR\n0\n‚Äã\n+\nR\n1\n‚Äã\n+\nR\n2\n‚Äã\nis the interest rate that would be charged at 100% utilization",
            "R\n0\nR_0\nR\n0\n‚Äã\nis the interest rate that would be charged at 0% utilization\nR\n0\n+\nR\n1\nR_0 + R_1\nR\n0\n‚Äã\n+\nR\n1\n‚Äã\nis the interest rate that would be charged at \nU\nÀâ\n%\n\\bar{U}\\% \nU\nÀâ\n%\nutilization\nR\n0\n+\nR\n1\n+\nR\n2\nR_0 + R_1 + R_2\nR\n0\n‚Äã\n+\nR\n1\n‚Äã\n+\nR\n2\n‚Äã\nis the interest rate that would be charged at 100% utilization"
        ],
        "tables": [],
        "code_blocks": [],
        "summaries": []
    },
    "https://docs.across.to/developer-docs/how-across-works/readme/validating-root-bundles": {
        "title": "Validating Root Bundles | Across Docs",
        "headers": [
            "Validating Root Bundles"
        ],
        "paragraphs": [
            "Root bundles instruct the Across system on how to transfer funds between smart contracts on different chains to refund relayers and fulfill user deposits.",
            "Last updated 1 year ago",
            "This explainer video explains why root bundles are critical to making the Across system work and how they are validated. Root bundles are optimistically validated and ultimately secured by the UMA Oracle. It is recommended that UMA voters and other actors in the UMA ecosystem have an understanding of how Across utilizes the UMA oracle."
        ],
        "lists": [
            "How Across Works\nOverview\nRoles within Across\nFee Model\nValidating Root Bundles\nDisputing Root Bundles\nDevelopers\nAcross API\nAcross SDK\nContract Addresses\nMainnet (Chain ID: 1)\nArbitrum (Chain ID: 42161)\nOptimism (Chain ID: 10)\nBase (Chain ID: 8453)\nzkSync (Chain ID: 324)\nPolygon (Chain ID: 137)\nSelected Contract Functions\nRunning a Relayer\nIntegrating Across into your application\nComposable Bridging\nDeveloper notes\nMigration from V2 to V3\nADDITIONAL INFO\nSupport Links\nBug Bounty\nAudits",
            "Overview\nRoles within Across\nFee Model\nValidating Root Bundles\nDisputing Root Bundles",
            "Roles within Across\nFee Model\nValidating Root Bundles\nDisputing Root Bundles",
            "Across API\nAcross SDK\nContract Addresses\nMainnet (Chain ID: 1)\nArbitrum (Chain ID: 42161)\nOptimism (Chain ID: 10)\nBase (Chain ID: 8453)\nzkSync (Chain ID: 324)\nPolygon (Chain ID: 137)\nSelected Contract Functions\nRunning a Relayer\nIntegrating Across into your application\nComposable Bridging\nDeveloper notes\nMigration from V2 to V3",
            "Mainnet (Chain ID: 1)\nArbitrum (Chain ID: 42161)\nOptimism (Chain ID: 10)\nBase (Chain ID: 8453)\nzkSync (Chain ID: 324)\nPolygon (Chain ID: 137)",
            "Support Links\nBug Bounty\nAudits"
        ],
        "tables": [],
        "code_blocks": [],
        "summaries": []
    },
    "https://docs.across.to/developer-docs/how-across-works/readme/disputing-root-bundles": {
        "title": "Disputing Root Bundles | Across Docs",
        "headers": [
            "Disputing Root Bundles",
            "About",
            "Manual Dispute Procedure",
            "Automated Dispute Procedure"
        ],
        "paragraphs": [
            "Across requires proposals and disputes to be accompanied by a bond. This bond is returned if the proposal or dispute is correct, and is sacrificed if it is found to be incorrect. This protects against attempts to incorrectly move funds, as well as spam and other denial of service attempts.",
            "The Across Bond Token (ABT) is the bond collateral required by the HubPool contract. This is a WETH-like contract that is minted in return for depositing Ether, and can be redeemed for the underlying Ether at any time. ABT implements custom ERC20 transferFrom() logic in order to limit the addresses that are able to make HubPool root bundle proposals.",
            "Check the required bond token and amount (nominally 0.45 ABT) by calling bondToken() and bondAmount() on the HubPool.",
            "Mint the bond token as necessary by caling deposit() on the BondToken contract.",
            "Ensure that the HubPool has permission to pull the bond during the dispute. Increase the allowance as necessary by calling appprove() on the BondToken contract. The address to approve is 0xc186fa914353c44b2e33ebe05f21846f1048beda. ",
            "Call disputeRootBundle() on the HubPool.",
            "The Across relayer-v2 repository contains a utility script that automates each of the above steps. Prerequisites are:",
            "The relayer-v2 package must be installed.",
            "The mnemonic for an EOA must be set in the relayer-v2 .env file.",
            "The configured EOA must be funded with at least 0.45 ABT or ETH  (1 ABT == 1 ETH), plus additional ETH for gas to handle the necessary deposit, approval and/or dispute transactions.",
            "It is sufficient for the entire amount to be held in ETH, since the dispute script automates the steps of minting ABT and approving the HubPool to spend it.",
            "The actual amounts are subject to change based on the prevailing gas price at the time of the dispute, and the configured bond amount.",
            "Last updated 1 year ago"
        ],
        "lists": [
            "How Across Works\nOverview\nRoles within Across\nFee Model\nValidating Root Bundles\nDisputing Root Bundles\nDevelopers\nAcross API\nAcross SDK\nContract Addresses\nMainnet (Chain ID: 1)\nArbitrum (Chain ID: 42161)\nOptimism (Chain ID: 10)\nBase (Chain ID: 8453)\nzkSync (Chain ID: 324)\nPolygon (Chain ID: 137)\nSelected Contract Functions\nRunning a Relayer\nIntegrating Across into your application\nComposable Bridging\nDeveloper notes\nMigration from V2 to V3\nADDITIONAL INFO\nSupport Links\nBug Bounty\nAudits",
            "Overview\nRoles within Across\nFee Model\nValidating Root Bundles\nDisputing Root Bundles",
            "Roles within Across\nFee Model\nValidating Root Bundles\nDisputing Root Bundles",
            "Across API\nAcross SDK\nContract Addresses\nMainnet (Chain ID: 1)\nArbitrum (Chain ID: 42161)\nOptimism (Chain ID: 10)\nBase (Chain ID: 8453)\nzkSync (Chain ID: 324)\nPolygon (Chain ID: 137)\nSelected Contract Functions\nRunning a Relayer\nIntegrating Across into your application\nComposable Bridging\nDeveloper notes\nMigration from V2 to V3",
            "Mainnet (Chain ID: 1)\nArbitrum (Chain ID: 42161)\nOptimism (Chain ID: 10)\nBase (Chain ID: 8453)\nzkSync (Chain ID: 324)\nPolygon (Chain ID: 137)",
            "Support Links\nBug Bounty\nAudits",
            "About\nManual Dispute Procedure\nAutomated Dispute Procedure"
        ],
        "tables": [],
        "code_blocks": [
            {
                "id": "8c699aa451b947a0b4d02c538aecff9d",
                "code": "$ git clone https://github.com/across-protocol/relayer-v2.git\n$ cd relayer-v2\n$ yarn install && yarn build\n\n# Copy the predefined sample config and update the MNEMONIC variable in\n# .env to match the relevant mnemonic.\n$ cp .env.example .env"
            },
            {
                "id": "61a5d2b170684ed5b96335bb2f2963e9",
                "code": "$ yarn dispute\n\n# The dispute script will dump information about the Bond Token and \n# latest HubPool proposal. If necessary, it will automatically mint the \n# requisite amount of the bond token and will approve the HubPool to use \n# it. At the conclusion, the script will provide the transaction hash of\n# the most recent proposal and will request to re-run with the flag\n#\n#     --txnHash <proposal-transaction-hash>\n# \n# Re-running the script with this additional argument will automatically \n# submit a dispute.\n\n$ yarn dispute --txnHash <proposal-transaction-hash>"
            }
        ],
        "summaries": []
    },
    "https://docs.across.to/developer-docs/developers/across-api": {
        "title": "Across API | Across Docs",
        "headers": [
            "Across API",
            "Source code:",
            "Caching & Liveness",
            "Calculating Suggested Fees",
            "Querying Limits",
            "Finding Available Routes"
        ],
        "paragraphs": [
            "The API is designed to be run serverlessly (without storing state) and is a wrapper on top of the SDK. Implementation here.",
            "Users of the Across API are requested to cache results for no longer than 300 seconds.",
            "The Across API serves data that is derived from the on-chain state of the Across contracts and relayer bots. The on-chain state is subject to change each block, and cached data can quickly become invalid as a result.",
            "The API uses the Across SDK under the hood, but offers a convenient way to get suggested fees when placing a Deposit transaction.",
            "Example:",
            "You can visit this example in your browser: Link.",
            "Or curl it on the CLI:",
            "curl \"https://across.to/api/suggested-fees?token=0x7f5c764cbc14f9669b88837ca1490cca17c31607&destinationChainId=42161&amount=100000000000\"",
            "Note: When filling relays, it is strongly recommended to use the Across SDK relayFeeCalculator. Using the suggested-fees API endpoint is done at the relayer's own risk.",
            "All API calls use https://across.to/apias the host.",
            "Path: /suggested-fees",
            "Method: GET",
            "Query Params",
            "token",
            "Address of token contract to transfer. For ETH (or other native tokens, like matic) use, use the wrapped address, like WETH.\n\nNote: the address provided can be the token address on any chain. In the unlikely event where two different tokens have the same address on different chains, you can use the optional chainId parameter defined below to indicate which chain should be used.",
            "0x7f5c764cbc14f9669b88837ca1490cca17c31607",
            "destinationChainId",
            "The intended destination of the transfer.",
            "42161",
            "amount",
            "Amount of the token to transfer. Note: this amount is in the native decimals of the token. So, for WETH, this would be the amount of human-readable WETH multiplied by 1e18. For USDC, you would multiply the number of human-readable USDC by 1e6.",
            "100000000000",
            "originChainId (optional)",
            "Used to specify which chain where the specified token address exists. Note: this is only needed to disambiguate when there are matching addresses on different chains. Otherwise, this can be inferred by the API.",
            "10",
            "recipient (optional)",
            "The recipient of the deposit. This can be an EOA or a contract. If this is an EOA and message is defined, then the API will throw a 4xx error.",
            "0xc186fa914353c44b2e33ebe05f21846f1048beda",
            "message (optional)",
            "Specifies calldata that is passed to the recipient if recipient is a contract address. This calldata is passed to the recipient via the recipient's handleAcrossMessage() public function here. The length of this value is constrained by the API to ~4096 chars minus the length of the full URL.",
            "0xABC123",
            "relayer (optional)",
            "Optionally override the relayer address used to simulate the fillRelay() call that estimates the gas costs needed to fill a deposit. This simulation result impacts the returned suggested-fees. The reason to customize the EOA would be primarily if the recipientAddress is a contract and requires a certain relayer to submit the fill, or if one specific relayer has the necessary token balance to make the fill.",
            "0x428ab2ba90eba0a4be7af34c9ac451ab061ac010",
            "timestamp (optional)",
            "The quote timestamp used to compute the LP fees. When bridging with across, the user only specifies the quote timestamp in their transaction. The relayer then determines the utilization at that timestamp to determine the user's fee. This timestamp must be close (within 10 minutes or so) to the current time on the chain where the user is depositing funds and it should be <= the current block timestamp on mainnet. This allows the user to know exactly what LP fee they will pay before sending the transaction.\n\nIf this value isn't provided in the request, the API will assume the latest block timestamp on mainnet.",
            "1653547649",
            "Returns a JSON object with the following properties:",
            "relayFeePct",
            "The percentage of the transfer amount that should go to the relayer as a fee. This is the strongly recommended minimum value to ensure a relayer will perform the transfer under the current network conditions.",
            "",
            "The value returned in this field is guaranteed to be at least 0.03% in order to meet minimum relayer fee requirements.",
            "",
            "Note: 1% is represented as 1e16, 100% is 1e18, 50% is 5e17, etc. These values are in the same format that the contract understands.",
            "61762946000000000",
            "lpFeePct",
            "The percent of the amount that will go to the LPs as a fee for borrowing their funds.\n\nThe formatting of the percentage is the same as relayFeePct .",
            "1252191895805000",
            "timestamp",
            "The quote timestamp that was used to compute the lpFeePct.",
            "",
            "To pay the quoted LP fee,  the user would need to pass this quote timestamp to the protocol when sending their bridge transaction.",
            "1646925270",
            "Errors: ",
            "400: invalid input.",
            "500: an unexpected error within the API.",
            "The API uses the UMA SDK under the hood, but offers a convenient way to get transfer limits.",
            "Example: Finding limits for bridging USDC from Optimism to Arbitrum.",
            "You can visit this example in your browser: Link",
            "Or curl it on the CLI: ",
            "curl \"https://across.to/api/limits?token=0x7f5c764cbc14f9669b88837ca1490cca17c31607&destinationChainId=42161\"",
            "All API calls use https://across.to/apias the host.",
            "Path: /limits",
            "Method: GET",
            "Query Params",
            "token",
            "Address of token contract to transfer. For ETH (or other native tokens, like matic) use, use the wrapped address, like WETH.\n\nNote: the address provided can be the token address on any chain. In the unlikely event where two different tokens have the same address on different chains, you can use the optional chainId parameter defined below to indicate which chain should be used.",
            "0x7f5c764cbc14f9669b88837ca1490cca17c31607",
            "destinationChainId",
            "The intended destination of the transfer.",
            "42161",
            "originChainId (optional)",
            "Used to specify which chain where the specified token address exists. Note: this is only needed to disambiguate when there are matching addresses on different chains. In that case, an arbitrary one will be chosen, so it is recommended that this is always provided.",
            "10",
            "Returns a JSON object with the following properties:",
            "minDeposit",
            "The minimum deposit size in the tokens' units.",
            "",
            "Note: USDC has 6 decimals, so this value would be the number of USDC multiplied by 1e6. For WETH, that would be 1e18.",
            "7799819",
            "maxDeposit",
            "The maximum deposit size in the tokens' units.",
            "",
            "Note: The formatting of this number is the same as minDeposit.",
            "22287428516241",
            "maxDepositInstant",
            "The max deposit size that can be relayed \"instantly\" on the destination chain. Instantly means that there is relayer capital readily available and that a relayer is expected to relay within 1-4 minutes of the deposit.",
            "201958902363",
            "maxDepositShortDelay",
            "The max deposit size that can be relayed with a \"short delay\" on the destination chain. This means that there is relayer capital available on mainnet and that a relayer will immediately begin moving that capital over the canonical bridge to relay the deposit. Depending on the chain, the time for this can vary. Polygon is the worst case where it can take between 20 and 35 minutes for the relayer to receive the funds and relay. Arbitrum is much faster, with a range between 5 and 15 minutes.\n\nNote: if the transfer size is greater than this, the estimate should be between 2-4 hours for a slow relay to be processed from the mainnet pool.",
            "2045367713809",
            "Errors: ",
            "400: invalid input.",
            "500: an unexpected error within the API.",
            "Example:",
            "You can visit this example in your browser: Link",
            "Or curl it on the CLI:",
            "curl \"https://across.to/api/available-routes\"",
            "All API calls use https://across.to/apias the host.",
            "Path: /available-routes",
            "Method: GET",
            "Query Params",
            "originChainId",
            "The chain ID of the originating chain to a bridge transfer. ",
            "",
            "Note: This is an optional query parameter. This parameter will filter the response JSON based. This filter can be used in addition to additional parameters to create a custom filter.",
            "1",
            "destinationChainId",
            "The chain ID of the destination chain to a bridge transfer. ",
            "",
            "Note: This is an optional query parameter. This parameter will filter the response JSON based. This filter can be used in addition to additional parameters to create a custom filter.",
            "10",
            "originToken",
            "The token address of the originating bridge transfer. ",
            "Must be a valid ERC-20 token address. ",
            "",
            "Note: This is an optional query parameter. This parameter will filter the response JSON based. This filter can be used in addition to additional parameters to create a custom filter.",
            "0xC02aaA39b223FE8D0A0e5C4F27eAD9083C756Cc2",
            "destinationToken",
            "The token address that funds will be transferred to at the destination chain. Must be a valid ERC-20 token address. ",
            "",
            "Note: This is an optional query parameter. This parameter will filter the response JSON based. This filter can be used in addition to additional parameters to create a custom filter.",
            "0x4200000000000000000000000000000000000006",
            "Returns a JSON array of Objects with the following properties:",
            "originChainId",
            "The chain ID of the originating chain to a bridge transfer. ",
            "1",
            "destinationChainId",
            "The chain ID of the destination chain to a bridge transfer. ",
            "10",
            "originToken",
            "The token address of the originating bridge transfer. ",
            "\nNote: this will be a valid ERC-20 token address. ",
            "0xC02aaA39b223FE8D0A0e5C4F27eAD9083C756Cc2",
            "destinationToken",
            "The token address that funds will be transferred to at the destination chain.\n\nNote: this will be a valid ERC-20 token address. ",
            "0x4200000000000000000000000000000000000006",
            "Errors: ",
            "400: invalid input.",
            "500: an unexpected error within the API.",
            "Last updated 11 months ago"
        ],
        "lists": [
            "How Across Works\nOverview\nRoles within Across\nFee Model\nValidating Root Bundles\nDisputing Root Bundles\nDevelopers\nAcross API\nAcross SDK\nContract Addresses\nMainnet (Chain ID: 1)\nArbitrum (Chain ID: 42161)\nOptimism (Chain ID: 10)\nBase (Chain ID: 8453)\nzkSync (Chain ID: 324)\nPolygon (Chain ID: 137)\nSelected Contract Functions\nRunning a Relayer\nIntegrating Across into your application\nComposable Bridging\nDeveloper notes\nMigration from V2 to V3\nADDITIONAL INFO\nSupport Links\nBug Bounty\nAudits",
            "Overview\nRoles within Across\nFee Model\nValidating Root Bundles\nDisputing Root Bundles",
            "Roles within Across\nFee Model\nValidating Root Bundles\nDisputing Root Bundles",
            "Across API\nAcross SDK\nContract Addresses\nMainnet (Chain ID: 1)\nArbitrum (Chain ID: 42161)\nOptimism (Chain ID: 10)\nBase (Chain ID: 8453)\nzkSync (Chain ID: 324)\nPolygon (Chain ID: 137)\nSelected Contract Functions\nRunning a Relayer\nIntegrating Across into your application\nComposable Bridging\nDeveloper notes\nMigration from V2 to V3",
            "Mainnet (Chain ID: 1)\nArbitrum (Chain ID: 42161)\nOptimism (Chain ID: 10)\nBase (Chain ID: 8453)\nzkSync (Chain ID: 324)\nPolygon (Chain ID: 137)",
            "Support Links\nBug Bounty\nAudits",
            "Source code:\nCaching & Liveness\nCalculating Suggested Fees\nQuerying Limits\nFinding Available Routes",
            "400: invalid input.\n500: an unexpected error within the API.",
            "400: invalid input.\n500: an unexpected error within the API.",
            "400: invalid input.\n500: an unexpected error within the API."
        ],
        "tables": [
            [
                [
                    "Parameter Name",
                    "Description",
                    "Example"
                ],
                [
                    "token",
                    "Address of token contract to transfer. For ETH (or other native tokens, like matic) use, use the wrapped address, like WETH.\n\nNote: the address provided can be the token address on any chain. In the unlikely event where two different tokens have the same address on different chains, you can use the optional chainId parameter defined below to indicate which chain should be used.",
                    "0x7f5c764cbc14f9669b88837ca1490cca17c31607"
                ],
                [
                    "destinationChainId",
                    "The intended destination of the transfer.",
                    "42161"
                ],
                [
                    "amount",
                    "Amount of the token to transfer. Note: this amount is in the native decimals of the token. So, for WETH, this would be the amount of human-readable WETH multiplied by 1e18. For USDC, you would multiply the number of human-readable USDC by 1e6.",
                    "100000000000"
                ],
                [
                    "originChainId (optional)",
                    "Used to specify which chain where the specified token address exists. Note: this is only needed to disambiguate when there are matching addresses on different chains. Otherwise, this can be inferred by the API.",
                    "10"
                ],
                [
                    "recipient (optional)",
                    "The recipient of the deposit. This can be an EOA or a contract. If this is an EOA and message is defined, then the API will throw a 4xx error.",
                    "0xc186fa914353c44b2e33ebe05f21846f1048beda"
                ],
                [
                    "message (optional)",
                    "Specifies calldata that is passed to the recipient if recipient is a contract address. This calldata is passed to the recipient via the recipient's handleAcrossMessage() public function here. The length of this value is constrained by the API to ~4096 chars minus the length of the full URL.",
                    "0xABC123"
                ],
                [
                    "relayer (optional)",
                    "Optionally override the relayer address used to simulate the fillRelay() call that estimates the gas costs needed to fill a deposit. This simulation result impacts the returned suggested-fees. The reason to customize the EOA would be primarily if the recipientAddress is a contract and requires a certain relayer to submit the fill, or if one specific relayer has the necessary token balance to make the fill.",
                    "0x428ab2ba90eba0a4be7af34c9ac451ab061ac010"
                ],
                [
                    "timestamp (optional)",
                    "The quote timestamp used to compute the LP fees. When bridging with across, the user only specifies the quote timestamp in their transaction. The relayer then determines the utilization at that timestamp to determine the user's fee. This timestamp must be close (within 10 minutes or so) to the current time on the chain where the user is depositing funds and it should be <= the current block timestamp on mainnet. This allows the user to know exactly what LP fee they will pay before sending the transaction.\n\nIf this value isn't provided in the request, the API will assume the latest block timestamp on mainnet.",
                    "1653547649"
                ]
            ],
            [
                [
                    "Property Name",
                    "Description",
                    "Example"
                ],
                [
                    "relayFeePct",
                    "The percentage of the transfer amount that should go to the relayer as a fee. This is the strongly recommended minimum value to ensure a relayer will perform the transfer under the current network conditions.The value returned in this field is guaranteed to be at least 0.03% in order to meet minimum relayer fee requirements.Note: 1% is represented as 1e16, 100% is 1e18, 50% is 5e17, etc. These values are in the same format that the contract understands.",
                    "61762946000000000"
                ],
                [
                    "lpFeePct",
                    "The percent of the amount that will go to the LPs as a fee for borrowing their funds.\n\nThe formatting of the percentage is the same as relayFeePct .",
                    "1252191895805000"
                ],
                [
                    "timestamp",
                    "The quote timestamp that was used to compute the lpFeePct.To pay the quoted LP fee,  the user would need to pass this quote timestamp to the protocol when sending their bridge transaction.",
                    "1646925270"
                ]
            ],
            [
                [
                    "Parameter Name",
                    "Description",
                    "Example"
                ],
                [
                    "token",
                    "Address of token contract to transfer. For ETH (or other native tokens, like matic) use, use the wrapped address, like WETH.\n\nNote: the address provided can be the token address on any chain. In the unlikely event where two different tokens have the same address on different chains, you can use the optional chainId parameter defined below to indicate which chain should be used.",
                    "0x7f5c764cbc14f9669b88837ca1490cca17c31607"
                ],
                [
                    "destinationChainId",
                    "The intended destination of the transfer.",
                    "42161"
                ],
                [
                    "originChainId (optional)",
                    "Used to specify which chain where the specified token address exists. Note: this is only needed to disambiguate when there are matching addresses on different chains. In that case, an arbitrary one will be chosen, so it is recommended that this is always provided.",
                    "10"
                ]
            ],
            [
                [
                    "Property Name",
                    "Description",
                    "Example"
                ],
                [
                    "minDeposit",
                    "The minimum deposit size in the tokens' units.Note: USDC has 6 decimals, so this value would be the number of USDC multiplied by 1e6. For WETH, that would be 1e18.",
                    "7799819"
                ],
                [
                    "maxDeposit",
                    "The maximum deposit size in the tokens' units.Note: The formatting of this number is the same as minDeposit.",
                    "22287428516241"
                ],
                [
                    "maxDepositInstant",
                    "The max deposit size that can be relayed \"instantly\" on the destination chain. Instantly means that there is relayer capital readily available and that a relayer is expected to relay within 1-4 minutes of the deposit.",
                    "201958902363"
                ],
                [
                    "maxDepositShortDelay",
                    "The max deposit size that can be relayed with a \"short delay\" on the destination chain. This means that there is relayer capital available on mainnet and that a relayer will immediately begin moving that capital over the canonical bridge to relay the deposit. Depending on the chain, the time for this can vary. Polygon is the worst case where it can take between 20 and 35 minutes for the relayer to receive the funds and relay. Arbitrum is much faster, with a range between 5 and 15 minutes.\n\nNote: if the transfer size is greater than this, the estimate should be between 2-4 hours for a slow relay to be processed from the mainnet pool.",
                    "2045367713809"
                ]
            ],
            [
                [
                    "Property Name",
                    "Description",
                    "Example"
                ],
                [
                    "originChainId",
                    "The chain ID of the originating chain to a bridge transfer. Note: This is an optional query parameter. This parameter will filter the response JSON based. This filter can be used in addition to additional parameters to create a custom filter.",
                    "1"
                ],
                [
                    "destinationChainId",
                    "The chain ID of the destination chain to a bridge transfer. Note: This is an optional query parameter. This parameter will filter the response JSON based. This filter can be used in addition to additional parameters to create a custom filter.",
                    "10"
                ],
                [
                    "originToken",
                    "The token address of the originating bridge transfer. Must be a valid ERC-20 token address. Note: This is an optional query parameter. This parameter will filter the response JSON based. This filter can be used in addition to additional parameters to create a custom filter.",
                    "0xC02aaA39b223FE8D0A0e5C4F27eAD9083C756Cc2"
                ],
                [
                    "destinationToken",
                    "The token address that funds will be transferred to at the destination chain. Must be a valid ERC-20 token address. Note: This is an optional query parameter. This parameter will filter the response JSON based. This filter can be used in addition to additional parameters to create a custom filter.",
                    "0x4200000000000000000000000000000000000006"
                ]
            ],
            [
                [
                    "Property Name",
                    "Description",
                    "Example"
                ],
                [
                    "originChainId",
                    "The chain ID of the originating chain to a bridge transfer.",
                    "1"
                ],
                [
                    "destinationChainId",
                    "The chain ID of the destination chain to a bridge transfer.",
                    "10"
                ],
                [
                    "originToken",
                    "The token address of the originating bridge transfer. \nNote: this will be a valid ERC-20 token address.",
                    "0xC02aaA39b223FE8D0A0e5C4F27eAD9083C756Cc2"
                ],
                [
                    "destinationToken",
                    "The token address that funds will be transferred to at the destination chain.\n\nNote: this will be a valid ERC-20 token address.",
                    "0x4200000000000000000000000000000000000006"
                ]
            ]
        ],
        "code_blocks": [],
        "summaries": []
    },
    "https://docs.across.to/developer-docs/developers/across-sdk": {
        "title": "Across SDK | Across Docs",
        "headers": [
            "Across SDK",
            "About the SDK",
            "How can I use the SDK?",
            "If I want to integrate Across into my dApp, should I use the SDK or the API?",
            "Installation",
            "Basic Usage"
        ],
        "paragraphs": [
            "The Across SDK is written and maintained by the engineering team at Risk Labs.",
            "It is written in typescript and available on NPM at @across-protocol/sdk-v2. It's compatible with both Node JS environments and in the browser.",
            "The SDK can be used currently to query suggested deposit fees and limits, and get liquidity pool statistics. It is imported and used in the API's implementation.",
            "We recommend using the API, which wraps SDK functions and has an easier interface. However, if speed is a concern then we recommend reviewing the API implementation of the SDK to understand best how to use the SDK. ",
            "To add the SDK to your project, use npm or yarn to npm install @across-protocol/sdk-v2 or yarn add @across-protocol/sdk-v2.",
            "This can be used either in a frontend application or a node js project. ",
            "You can read about the different SDK modules on the Github README page. For convenience, the available modules are:",
            "lpFeeCalculator: Get liquidity provider fee that will be charged on deposit for its quoteTimestamp",
            "relayFeeCalculator: Get suggested relayerFeePct for a deposit, which accounts for opportunity cost of capital and gas costs. If the depositor opts to set this fee lower than the suggested fee, then there is a chance that the deposit goes unfilled for a long time.",
            "pool: Get HubPool statistics, such as available liquidReserves that be used to refund relayers and estimatedApy for liquidity providers.",
            "Last updated 1 year ago"
        ],
        "lists": [
            "How Across Works\nOverview\nRoles within Across\nFee Model\nValidating Root Bundles\nDisputing Root Bundles\nDevelopers\nAcross API\nAcross SDK\nContract Addresses\nMainnet (Chain ID: 1)\nArbitrum (Chain ID: 42161)\nOptimism (Chain ID: 10)\nBase (Chain ID: 8453)\nzkSync (Chain ID: 324)\nPolygon (Chain ID: 137)\nSelected Contract Functions\nRunning a Relayer\nIntegrating Across into your application\nComposable Bridging\nDeveloper notes\nMigration from V2 to V3\nADDITIONAL INFO\nSupport Links\nBug Bounty\nAudits",
            "Overview\nRoles within Across\nFee Model\nValidating Root Bundles\nDisputing Root Bundles",
            "Roles within Across\nFee Model\nValidating Root Bundles\nDisputing Root Bundles",
            "Across API\nAcross SDK\nContract Addresses\nMainnet (Chain ID: 1)\nArbitrum (Chain ID: 42161)\nOptimism (Chain ID: 10)\nBase (Chain ID: 8453)\nzkSync (Chain ID: 324)\nPolygon (Chain ID: 137)\nSelected Contract Functions\nRunning a Relayer\nIntegrating Across into your application\nComposable Bridging\nDeveloper notes\nMigration from V2 to V3",
            "Mainnet (Chain ID: 1)\nArbitrum (Chain ID: 42161)\nOptimism (Chain ID: 10)\nBase (Chain ID: 8453)\nzkSync (Chain ID: 324)\nPolygon (Chain ID: 137)",
            "Support Links\nBug Bounty\nAudits",
            "About the SDK\nHow can I use the SDK?\nIf I want to integrate Across into my dApp, should I use the SDK or the API?\nInstallation\nBasic Usage",
            "lpFeeCalculator: Get \nliquidity provider fee\n that will be charged on deposit for its \nquoteTimestamp\nrelayFeeCalculator: Get suggested \nrelayerFeePct\n for a deposit, which accounts for \nopportunity cost of capital and gas costs\n. If the depositor opts to set this fee lower than the suggested fee, then there is a chance that the deposit goes unfilled for a long time.\npool: Get HubPool statistics, such as available \nliquidReserves\n that be used to refund relayers and \nestimatedApy\n for \nliquidity providers\n."
        ],
        "tables": [],
        "code_blocks": [],
        "summaries": []
    },
    "https://docs.across.to/developer-docs/developers/contract-addresses": {
        "title": "Contract Addresses | Across Docs",
        "headers": [
            "Contract Addresses"
        ],
        "paragraphs": [
            "You can find the contract addresses on the following pages:",
            "Mainnet",
            "Arbitrum",
            "Optimism",
            "Base",
            "zkSync",
            "Polygon",
            "Boba",
            "These addresses can also be found on the Across github",
            "Last updated 1 year ago"
        ],
        "lists": [
            "How Across Works\nOverview\nRoles within Across\nFee Model\nValidating Root Bundles\nDisputing Root Bundles\nDevelopers\nAcross API\nAcross SDK\nContract Addresses\nMainnet (Chain ID: 1)\nArbitrum (Chain ID: 42161)\nOptimism (Chain ID: 10)\nBase (Chain ID: 8453)\nzkSync (Chain ID: 324)\nPolygon (Chain ID: 137)\nSelected Contract Functions\nRunning a Relayer\nIntegrating Across into your application\nComposable Bridging\nDeveloper notes\nMigration from V2 to V3\nADDITIONAL INFO\nSupport Links\nBug Bounty\nAudits",
            "Overview\nRoles within Across\nFee Model\nValidating Root Bundles\nDisputing Root Bundles",
            "Roles within Across\nFee Model\nValidating Root Bundles\nDisputing Root Bundles",
            "Across API\nAcross SDK\nContract Addresses\nMainnet (Chain ID: 1)\nArbitrum (Chain ID: 42161)\nOptimism (Chain ID: 10)\nBase (Chain ID: 8453)\nzkSync (Chain ID: 324)\nPolygon (Chain ID: 137)\nSelected Contract Functions\nRunning a Relayer\nIntegrating Across into your application\nComposable Bridging\nDeveloper notes\nMigration from V2 to V3",
            "Mainnet (Chain ID: 1)\nArbitrum (Chain ID: 42161)\nOptimism (Chain ID: 10)\nBase (Chain ID: 8453)\nzkSync (Chain ID: 324)\nPolygon (Chain ID: 137)",
            "Support Links\nBug Bounty\nAudits",
            "Mainnet\nArbitrum\nOptimism\nBase\nzkSync\nPolygon\nBoba"
        ],
        "tables": [],
        "code_blocks": [],
        "summaries": []
    },
    "https://docs.across.to/developer-docs/developers/contract-addresses/mainnet-chain-id-1": {
        "title": "Mainnet (Chain ID: 1) | Across Docs",
        "headers": [
            "Mainnet (Chain ID: 1)"
        ],
        "paragraphs": [
            "",
            "LPTokenFactory",
            "0x7dB69eb9F52eD773E9b03f5068A1ea0275b2fD9d",
            "HubPool",
            "0xc186fA914353c44b2E33eBE05f21846F1048bEda",
            "Optimism_Adapter",
            "0xAd1b0a86c98703fd5F4E56fff04F6b2D9b9f246F",
            "Boba_Adapter",
            "0x33B0Ec794c15D6Cc705818E70d4CaCe7bCfB5Af3",
            "Arbitrum_Adapter",
            "0x29528780E29abb8Af95a5e5a125b94766987543F",
            "Ethereum_Adapter",
            "0x527E872a5c3f0C7c24Fe33F2593cFB890a285084",
            "Ethereum_SpokePool",
            "0x5c7BCd6E7De5423a257D81B442095A1a6ced35C5",
            "PolygonTokenBridger",
            "0x0330E9b4D0325cCfF515E81DFbc7754F2a02ac57",
            "Polygon_Adapter",
            "0x3E94e8d4316a1eBfb2245E45E6F0B8724094CE1A",
            "zkSync Adapter",
            "0xE233009838CB898b50e0012a6E783FC9FeE447FB",
            "Base Adapter",
            "0x2d8B1e2B0Dff62DF132d23BEa68a6D2c4D20046E",
            "AcrossConfigStore",
            "0x3B03509645713718B78951126E0A6de6f10043f5",
            "AcceleratingDistributor",
            "0x9040e41eF5E8b281535a96D9a48aCb8cfaBD9a48",
            "AcrossMerkleDistributor",
            "0xE50b2cEAC4f60E840Ae513924033E753e2366487",
            "ClaimAndStake",
            "0x985e8A89Dd6Af8896Ef075c8dd93512433dc5829",
            "Across Governance Token",
            "0x44108f0223A3C3028F5Fe7AEC7f9bb2E66beF82F",
            "Across Bond Token",
            "0xee1DC6BCF1Ee967a350e9aC6CaaAA236109002ea",
            "",
            "Last updated 1 year ago"
        ],
        "lists": [
            "How Across Works\nOverview\nRoles within Across\nFee Model\nValidating Root Bundles\nDisputing Root Bundles\nDevelopers\nAcross API\nAcross SDK\nContract Addresses\nMainnet (Chain ID: 1)\nArbitrum (Chain ID: 42161)\nOptimism (Chain ID: 10)\nBase (Chain ID: 8453)\nzkSync (Chain ID: 324)\nPolygon (Chain ID: 137)\nSelected Contract Functions\nRunning a Relayer\nIntegrating Across into your application\nComposable Bridging\nDeveloper notes\nMigration from V2 to V3\nADDITIONAL INFO\nSupport Links\nBug Bounty\nAudits",
            "Overview\nRoles within Across\nFee Model\nValidating Root Bundles\nDisputing Root Bundles",
            "Roles within Across\nFee Model\nValidating Root Bundles\nDisputing Root Bundles",
            "Across API\nAcross SDK\nContract Addresses\nMainnet (Chain ID: 1)\nArbitrum (Chain ID: 42161)\nOptimism (Chain ID: 10)\nBase (Chain ID: 8453)\nzkSync (Chain ID: 324)\nPolygon (Chain ID: 137)\nSelected Contract Functions\nRunning a Relayer\nIntegrating Across into your application\nComposable Bridging\nDeveloper notes\nMigration from V2 to V3",
            "Mainnet (Chain ID: 1)\nArbitrum (Chain ID: 42161)\nOptimism (Chain ID: 10)\nBase (Chain ID: 8453)\nzkSync (Chain ID: 324)\nPolygon (Chain ID: 137)",
            "Support Links\nBug Bounty\nAudits"
        ],
        "tables": [
            [
                [
                    "Contract Name",
                    "Address"
                ],
                [
                    "LPTokenFactory",
                    "0x7dB69eb9F52eD773E9b03f5068A1ea0275b2fD9d"
                ],
                [
                    "HubPool",
                    "0xc186fA914353c44b2E33eBE05f21846F1048bEda"
                ],
                [
                    "Optimism_Adapter",
                    "0xAd1b0a86c98703fd5F4E56fff04F6b2D9b9f246F"
                ],
                [
                    "Boba_Adapter",
                    "0x33B0Ec794c15D6Cc705818E70d4CaCe7bCfB5Af3"
                ],
                [
                    "Arbitrum_Adapter",
                    "0x29528780E29abb8Af95a5e5a125b94766987543F"
                ],
                [
                    "Ethereum_Adapter",
                    "0x527E872a5c3f0C7c24Fe33F2593cFB890a285084"
                ],
                [
                    "Ethereum_SpokePool",
                    "0x5c7BCd6E7De5423a257D81B442095A1a6ced35C5"
                ],
                [
                    "PolygonTokenBridger",
                    "0x0330E9b4D0325cCfF515E81DFbc7754F2a02ac57"
                ],
                [
                    "Polygon_Adapter",
                    "0x3E94e8d4316a1eBfb2245E45E6F0B8724094CE1A"
                ],
                [
                    "zkSync Adapter",
                    "0xE233009838CB898b50e0012a6E783FC9FeE447FB"
                ],
                [
                    "Base Adapter",
                    "0x2d8B1e2B0Dff62DF132d23BEa68a6D2c4D20046E"
                ],
                [
                    "AcrossConfigStore",
                    "0x3B03509645713718B78951126E0A6de6f10043f5"
                ],
                [
                    "AcceleratingDistributor",
                    "0x9040e41eF5E8b281535a96D9a48aCb8cfaBD9a48"
                ],
                [
                    "AcrossMerkleDistributor",
                    "0xE50b2cEAC4f60E840Ae513924033E753e2366487"
                ],
                [
                    "ClaimAndStake",
                    "0x985e8A89Dd6Af8896Ef075c8dd93512433dc5829"
                ],
                [
                    "Across Governance Token",
                    "0x44108f0223A3C3028F5Fe7AEC7f9bb2E66beF82F"
                ],
                [
                    "Across Bond Token",
                    "0xee1DC6BCF1Ee967a350e9aC6CaaAA236109002ea"
                ]
            ]
        ],
        "code_blocks": [],
        "summaries": []
    },
    "https://docs.across.to/developer-docs/developers/contract-addresses/arbitrum-chain-id-42161": {
        "title": "Arbitrum (Chain ID: 42161) | Across Docs",
        "headers": [
            "Arbitrum (Chain ID: 42161)"
        ],
        "paragraphs": [
            "",
            "Arbitrum_SpokePool",
            "0xe35e9842fceaca96570b734083f4a58e8f7c5f2a",
            "Across Governance Token",
            "0x53691596d1BCe8CEa565b84d4915e69e03d9C99d",
            "Last updated 1 year ago"
        ],
        "lists": [
            "How Across Works\nOverview\nRoles within Across\nFee Model\nValidating Root Bundles\nDisputing Root Bundles\nDevelopers\nAcross API\nAcross SDK\nContract Addresses\nMainnet (Chain ID: 1)\nArbitrum (Chain ID: 42161)\nOptimism (Chain ID: 10)\nBase (Chain ID: 8453)\nzkSync (Chain ID: 324)\nPolygon (Chain ID: 137)\nSelected Contract Functions\nRunning a Relayer\nIntegrating Across into your application\nComposable Bridging\nDeveloper notes\nMigration from V2 to V3\nADDITIONAL INFO\nSupport Links\nBug Bounty\nAudits",
            "Overview\nRoles within Across\nFee Model\nValidating Root Bundles\nDisputing Root Bundles",
            "Roles within Across\nFee Model\nValidating Root Bundles\nDisputing Root Bundles",
            "Across API\nAcross SDK\nContract Addresses\nMainnet (Chain ID: 1)\nArbitrum (Chain ID: 42161)\nOptimism (Chain ID: 10)\nBase (Chain ID: 8453)\nzkSync (Chain ID: 324)\nPolygon (Chain ID: 137)\nSelected Contract Functions\nRunning a Relayer\nIntegrating Across into your application\nComposable Bridging\nDeveloper notes\nMigration from V2 to V3",
            "Mainnet (Chain ID: 1)\nArbitrum (Chain ID: 42161)\nOptimism (Chain ID: 10)\nBase (Chain ID: 8453)\nzkSync (Chain ID: 324)\nPolygon (Chain ID: 137)",
            "Support Links\nBug Bounty\nAudits"
        ],
        "tables": [
            [
                [
                    "Contract Name",
                    "Address"
                ],
                [
                    "Arbitrum_SpokePool",
                    "0xe35e9842fceaca96570b734083f4a58e8f7c5f2a"
                ],
                [
                    "Across Governance Token",
                    "0x53691596d1BCe8CEa565b84d4915e69e03d9C99d"
                ]
            ]
        ],
        "code_blocks": [],
        "summaries": []
    },
    "https://docs.across.to/developer-docs/developers/contract-addresses/optimism-chain-id-10": {
        "title": "Optimism (Chain ID: 10) | Across Docs",
        "headers": [
            "Optimism (Chain ID: 10)"
        ],
        "paragraphs": [
            "",
            "Optimism_SpokePool",
            "0x6f26Bf09B1C792e3228e5467807a900A503c0281",
            "Across Governance Token",
            "0xFf733b2A3557a7ed6697007ab5D11B79FdD1b76B",
            "Last updated 1 year ago"
        ],
        "lists": [
            "How Across Works\nOverview\nRoles within Across\nFee Model\nValidating Root Bundles\nDisputing Root Bundles\nDevelopers\nAcross API\nAcross SDK\nContract Addresses\nMainnet (Chain ID: 1)\nArbitrum (Chain ID: 42161)\nOptimism (Chain ID: 10)\nBase (Chain ID: 8453)\nzkSync (Chain ID: 324)\nPolygon (Chain ID: 137)\nSelected Contract Functions\nRunning a Relayer\nIntegrating Across into your application\nComposable Bridging\nDeveloper notes\nMigration from V2 to V3\nADDITIONAL INFO\nSupport Links\nBug Bounty\nAudits",
            "Overview\nRoles within Across\nFee Model\nValidating Root Bundles\nDisputing Root Bundles",
            "Roles within Across\nFee Model\nValidating Root Bundles\nDisputing Root Bundles",
            "Across API\nAcross SDK\nContract Addresses\nMainnet (Chain ID: 1)\nArbitrum (Chain ID: 42161)\nOptimism (Chain ID: 10)\nBase (Chain ID: 8453)\nzkSync (Chain ID: 324)\nPolygon (Chain ID: 137)\nSelected Contract Functions\nRunning a Relayer\nIntegrating Across into your application\nComposable Bridging\nDeveloper notes\nMigration from V2 to V3",
            "Mainnet (Chain ID: 1)\nArbitrum (Chain ID: 42161)\nOptimism (Chain ID: 10)\nBase (Chain ID: 8453)\nzkSync (Chain ID: 324)\nPolygon (Chain ID: 137)",
            "Support Links\nBug Bounty\nAudits"
        ],
        "tables": [
            [
                [
                    "Contract Name",
                    "Address"
                ],
                [
                    "Optimism_SpokePool",
                    "0x6f26Bf09B1C792e3228e5467807a900A503c0281"
                ],
                [
                    "Across Governance Token",
                    "0xFf733b2A3557a7ed6697007ab5D11B79FdD1b76B"
                ]
            ]
        ],
        "code_blocks": [],
        "summaries": []
    },
    "https://docs.across.to/developer-docs/developers/contract-addresses/base-chain-id-8453": {
        "title": "Base (Chain ID: 8453) | Across Docs",
        "headers": [
            "Base (Chain ID: 8453)"
        ],
        "paragraphs": [
            "",
            "Base_SpokePool",
            "0x09aea4b2242abC8bb4BB78D537A67a245A7bEC64",
            "",
            "Last updated 1 year ago"
        ],
        "lists": [
            "How Across Works\nOverview\nRoles within Across\nFee Model\nValidating Root Bundles\nDisputing Root Bundles\nDevelopers\nAcross API\nAcross SDK\nContract Addresses\nMainnet (Chain ID: 1)\nArbitrum (Chain ID: 42161)\nOptimism (Chain ID: 10)\nBase (Chain ID: 8453)\nzkSync (Chain ID: 324)\nPolygon (Chain ID: 137)\nSelected Contract Functions\nRunning a Relayer\nIntegrating Across into your application\nComposable Bridging\nDeveloper notes\nMigration from V2 to V3\nADDITIONAL INFO\nSupport Links\nBug Bounty\nAudits",
            "Overview\nRoles within Across\nFee Model\nValidating Root Bundles\nDisputing Root Bundles",
            "Roles within Across\nFee Model\nValidating Root Bundles\nDisputing Root Bundles",
            "Across API\nAcross SDK\nContract Addresses\nMainnet (Chain ID: 1)\nArbitrum (Chain ID: 42161)\nOptimism (Chain ID: 10)\nBase (Chain ID: 8453)\nzkSync (Chain ID: 324)\nPolygon (Chain ID: 137)\nSelected Contract Functions\nRunning a Relayer\nIntegrating Across into your application\nComposable Bridging\nDeveloper notes\nMigration from V2 to V3",
            "Mainnet (Chain ID: 1)\nArbitrum (Chain ID: 42161)\nOptimism (Chain ID: 10)\nBase (Chain ID: 8453)\nzkSync (Chain ID: 324)\nPolygon (Chain ID: 137)",
            "Support Links\nBug Bounty\nAudits"
        ],
        "tables": [
            [
                [
                    "Contract Name",
                    "Address"
                ],
                [
                    "Base_SpokePool",
                    "0x09aea4b2242abC8bb4BB78D537A67a245A7bEC64"
                ]
            ]
        ],
        "code_blocks": [],
        "summaries": []
    },
    "https://docs.across.to/developer-docs/developers/contract-addresses/zksync-chain-id-324": {
        "title": "zkSync (Chain ID: 324) | Across Docs",
        "headers": [
            "zkSync (Chain ID: 324)"
        ],
        "paragraphs": [
            "",
            "zkSync_SpokePool",
            "0xE0B015E54d54fc84a6cB9B666099c46adE9335FF",
            "Last updated 1 year ago"
        ],
        "lists": [
            "How Across Works\nOverview\nRoles within Across\nFee Model\nValidating Root Bundles\nDisputing Root Bundles\nDevelopers\nAcross API\nAcross SDK\nContract Addresses\nMainnet (Chain ID: 1)\nArbitrum (Chain ID: 42161)\nOptimism (Chain ID: 10)\nBase (Chain ID: 8453)\nzkSync (Chain ID: 324)\nPolygon (Chain ID: 137)\nSelected Contract Functions\nRunning a Relayer\nIntegrating Across into your application\nComposable Bridging\nDeveloper notes\nMigration from V2 to V3\nADDITIONAL INFO\nSupport Links\nBug Bounty\nAudits",
            "Overview\nRoles within Across\nFee Model\nValidating Root Bundles\nDisputing Root Bundles",
            "Roles within Across\nFee Model\nValidating Root Bundles\nDisputing Root Bundles",
            "Across API\nAcross SDK\nContract Addresses\nMainnet (Chain ID: 1)\nArbitrum (Chain ID: 42161)\nOptimism (Chain ID: 10)\nBase (Chain ID: 8453)\nzkSync (Chain ID: 324)\nPolygon (Chain ID: 137)\nSelected Contract Functions\nRunning a Relayer\nIntegrating Across into your application\nComposable Bridging\nDeveloper notes\nMigration from V2 to V3",
            "Mainnet (Chain ID: 1)\nArbitrum (Chain ID: 42161)\nOptimism (Chain ID: 10)\nBase (Chain ID: 8453)\nzkSync (Chain ID: 324)\nPolygon (Chain ID: 137)",
            "Support Links\nBug Bounty\nAudits"
        ],
        "tables": [
            [
                [
                    "Contract Name",
                    "Address"
                ],
                [
                    "zkSync_SpokePool",
                    "0xE0B015E54d54fc84a6cB9B666099c46adE9335FF"
                ]
            ]
        ],
        "code_blocks": [],
        "summaries": []
    },
    "https://docs.across.to/developer-docs/developers/contract-addresses/polygon-chain-id-137": {
        "title": "Polygon (Chain ID: 137) | Across Docs",
        "headers": [
            "Polygon (Chain ID: 137)"
        ],
        "paragraphs": [
            "",
            "PolygonTokenBridger",
            "0x0330E9b4D0325cCfF515E81DFbc7754F2a02ac57",
            "Polygon_SpokePool",
            "0x9295ee1d8C5b022Be115A2AD3c30C72E34e7F096",
            "Across Governance Token",
            "0xF328b73B6c685831F238c30a23Fc19140CB4D8FC",
            "Last updated 1 year ago"
        ],
        "lists": [
            "How Across Works\nOverview\nRoles within Across\nFee Model\nValidating Root Bundles\nDisputing Root Bundles\nDevelopers\nAcross API\nAcross SDK\nContract Addresses\nMainnet (Chain ID: 1)\nArbitrum (Chain ID: 42161)\nOptimism (Chain ID: 10)\nBase (Chain ID: 8453)\nzkSync (Chain ID: 324)\nPolygon (Chain ID: 137)\nSelected Contract Functions\nRunning a Relayer\nIntegrating Across into your application\nComposable Bridging\nDeveloper notes\nMigration from V2 to V3\nADDITIONAL INFO\nSupport Links\nBug Bounty\nAudits",
            "Overview\nRoles within Across\nFee Model\nValidating Root Bundles\nDisputing Root Bundles",
            "Roles within Across\nFee Model\nValidating Root Bundles\nDisputing Root Bundles",
            "Across API\nAcross SDK\nContract Addresses\nMainnet (Chain ID: 1)\nArbitrum (Chain ID: 42161)\nOptimism (Chain ID: 10)\nBase (Chain ID: 8453)\nzkSync (Chain ID: 324)\nPolygon (Chain ID: 137)\nSelected Contract Functions\nRunning a Relayer\nIntegrating Across into your application\nComposable Bridging\nDeveloper notes\nMigration from V2 to V3",
            "Mainnet (Chain ID: 1)\nArbitrum (Chain ID: 42161)\nOptimism (Chain ID: 10)\nBase (Chain ID: 8453)\nzkSync (Chain ID: 324)\nPolygon (Chain ID: 137)",
            "Support Links\nBug Bounty\nAudits"
        ],
        "tables": [
            [
                [
                    "Contract Name",
                    "Address"
                ],
                [
                    "PolygonTokenBridger",
                    "0x0330E9b4D0325cCfF515E81DFbc7754F2a02ac57"
                ],
                [
                    "Polygon_SpokePool",
                    "0x9295ee1d8C5b022Be115A2AD3c30C72E34e7F096"
                ],
                [
                    "Across Governance Token",
                    "0xF328b73B6c685831F238c30a23Fc19140CB4D8FC"
                ]
            ]
        ],
        "code_blocks": [],
        "summaries": []
    },
    "https://docs.across.to/developer-docs/developers/selected-contract-functions": {
        "title": "Selected Contract Functions | Across Docs",
        "headers": [
            "Selected Contract Functions",
            "SpokePool state-modifying functions",
            "deposit ",
            "speedUpDeposit "
        ],
        "paragraphs": [
            "Explanation of most commonly used smart contract functions",
            "The spoke pool contract is where deposits are originated and fulfilled. ",
            "This triggers a deposit request of tokens to another chain with the following parameters. The originChainId is automatically set to the chain ID on which the SpokePool is deployed. For example, sending a deposit from the Optimism_SpokePool will set its originChainId equal to 10. ",
            "Note on sending ETH: deposit is a payable function meaning it is possible to send native ETH instead of wrapped ETH (i.e. WETH). If you choose to send ETH, you must set msg.value equal to amount.",
            "Note on approvals: the caller must approve the SpokePool to transfer amount of tokens.",
            "Note on amount limits: If the amount is set too high, it can take a while for the deposit to be filled depending on available relayer liquidity. If the amount is set too low, it can be unprofitable to relay regardless of the relayer fee %. Query the suggested max and min limits here. The contracts will not revert if the amount is set outside of the recommended range, so it is highly recommended to set amount within the suggested limits to avoid locking up funds for an unexpected length of time.",
            "Note on setting quoteTimestamp: ",
            "Call the read-only function getCurrentTime() to get the current UNIX timestamp on the origin chain. e.g. this could return: 1665418548.",
            "Call the read-only function depositQuoteTimeBuffer() to get the buffer around the current time that the quoteTimestamp must be set to. e.g. this could return: 600.",
            "quoteTimestamp must be <= currentTime + buffer and >= currentTime - buffer.",
            "address",
            "recipient",
            "Receiver of bridged funds on destination chain.",
            "address",
            "originToken",
            "Bridged token address on origin chain.",
            "uint256",
            "amount",
            "Amount of tokens to send on origin chain. Receiver receives this amount minus fees on destination chain.",
            "uint256",
            "destinationChainId",
            "Where bridged funds should be sent to recipient. Recipient will receive the equivalent of the originToken on the destination chain. The mapping of  destination and origin tokens can be queried  here.",
            "uint64",
            "relayerFeePct",
            "% of amount to pay to relayer. Must be less than 0.5e18 (i.e. 50%). Suggested fees can be queried here. Be careful: if this % is set too low, relayers could be disincentivized to fill this deposit quickly. This can be sped up by calling speedUpDeposit. ",
            "uint32",
            "quoteTimestamp",
            "Timestamp of deposit. Used by relayers to compute the LP fee % for the deposit. Must be withindepositQuoteTimeBuffer() of the current time.",
            "bytes",
            "message",
            "Data that can be passed to the recipient if it is a contract. If no message is to be sent, set this field to an empty bytes array: \"\"(i.e. bytes` of length 0, or the \"empty string\").\n\nSee Composable Bridging for examples on how messaging can be used.",
            "uint256",
            "maxCount",
            "This parameter can be set to protect against front-running in the new UBA fee model. Stay tuned for updates about this feature. For now, set this to UINT256.MAX_UINT to avoid deposit reverts.",
            "Some of a pending deposit's parameters can be modified by calling this function. If a deposit has been completed already, this function will not revert but it won't be able to be filled anymore with the updated params. It is the responsibility of the depositor to verify that the deposit has not been fully filled before calling this function.",
            "A depositor can request modifications by signing a hash containing the updated details and information uniquely identifying the deposit to relay. This information ensures that this signature cannot be re-used for other deposits.",
            "We use the EIP-712 standard for hashing and signing typed data. Specifically, we use the version of the encoding known as \"v4\", as implemented by the JSON RPC method eth_signedTypedDataV4 in MetaMask. ",
            "You can see how the message to be signed is reconstructed in Solidity here.",
            "Successfully calling this function will emit an event RequestedSpeedUpDeposit which can be used by relayers to fill the original deposit with the new parameters.  Depositors should assume that the parameters emitted with the highest relayerFeePct will be used, since they are incentivized to use the highest fee possible.",
            "Any relayer can use updated deposit parameters by calling fillRelayWithUpdatedDeposit instead of fillRelay.",
            "address",
            "depositor",
            "Sender of deposit to be sped up. Does not need to equal msg.sender",
            "int64",
            "updatedRelayerFeePct",
            "New relayer fee % that relayers can use when calling fillDepositWithUpdatedDeposit",
            "uint32",
            "depositId",
            "UUID of deposit to be sped up",
            "address",
            "updatedRecipient",
            "New recipient of deposit.",
            "bytes",
            "updatedMessage",
            "Updated data that is sent to updatedRecipient. As described in section above, this should be set to 0x for the forseeable future.",
            "bytes",
            "depositorSignature",
            "Signed message containing contents here",
            "Last updated 9 months ago"
        ],
        "lists": [
            "How Across Works\nOverview\nRoles within Across\nFee Model\nValidating Root Bundles\nDisputing Root Bundles\nDevelopers\nAcross API\nAcross SDK\nContract Addresses\nMainnet (Chain ID: 1)\nArbitrum (Chain ID: 42161)\nOptimism (Chain ID: 10)\nBase (Chain ID: 8453)\nzkSync (Chain ID: 324)\nPolygon (Chain ID: 137)\nSelected Contract Functions\nRunning a Relayer\nIntegrating Across into your application\nComposable Bridging\nDeveloper notes\nMigration from V2 to V3\nADDITIONAL INFO\nSupport Links\nBug Bounty\nAudits",
            "Overview\nRoles within Across\nFee Model\nValidating Root Bundles\nDisputing Root Bundles",
            "Roles within Across\nFee Model\nValidating Root Bundles\nDisputing Root Bundles",
            "Across API\nAcross SDK\nContract Addresses\nMainnet (Chain ID: 1)\nArbitrum (Chain ID: 42161)\nOptimism (Chain ID: 10)\nBase (Chain ID: 8453)\nzkSync (Chain ID: 324)\nPolygon (Chain ID: 137)\nSelected Contract Functions\nRunning a Relayer\nIntegrating Across into your application\nComposable Bridging\nDeveloper notes\nMigration from V2 to V3",
            "Mainnet (Chain ID: 1)\nArbitrum (Chain ID: 42161)\nOptimism (Chain ID: 10)\nBase (Chain ID: 8453)\nzkSync (Chain ID: 324)\nPolygon (Chain ID: 137)",
            "Support Links\nBug Bounty\nAudits",
            "SpokePool state-modifying functions\ndeposit \nspeedUpDeposit"
        ],
        "tables": [
            [
                [
                    "Type",
                    "Name",
                    "Explanation"
                ],
                [
                    "address",
                    "recipient",
                    "Receiver of bridged funds on destination chain."
                ],
                [
                    "address",
                    "originToken",
                    "Bridged token address on origin chain."
                ],
                [
                    "uint256",
                    "amount",
                    "Amount of tokens to send on origin chain. Receiver receives this amount minus fees on destination chain."
                ],
                [
                    "uint256",
                    "destinationChainId",
                    "Where bridged funds should be sent to recipient. Recipient will receive the equivalent of the originToken on the destination chain. The mapping of  destination and origin tokens can be queried  here."
                ],
                [
                    "uint64",
                    "relayerFeePct",
                    "% of amount to pay to relayer. Must be less than 0.5e18 (i.e. 50%). Suggested fees can be queried here. Be careful: if this % is set too low, relayers could be disincentivized to fill this deposit quickly. This can be sped up by calling speedUpDeposit."
                ],
                [
                    "uint32",
                    "quoteTimestamp",
                    "Timestamp of deposit. Used by relayers to compute the LP fee % for the deposit. Must be withindepositQuoteTimeBuffer() of the current time."
                ],
                [
                    "bytes",
                    "message",
                    "Data that can be passed to the recipient if it is a contract. If no message is to be sent, set this field to an empty bytes array: \"\"(i.e. bytes` of length 0, or the \"empty string\").\n\nSee Composable Bridging for examples on how messaging can be used."
                ],
                [
                    "uint256",
                    "maxCount",
                    "This parameter can be set to protect against front-running in the new UBA fee model. Stay tuned for updates about this feature. For now, set this to UINT256.MAX_UINT to avoid deposit reverts."
                ]
            ],
            [
                [
                    "Type",
                    "Name",
                    "Description"
                ],
                [
                    "address",
                    "depositor",
                    "Sender of deposit to be sped up. Does not need to equal msg.sender"
                ],
                [
                    "int64",
                    "updatedRelayerFeePct",
                    "New relayer fee % that relayers can use when calling fillDepositWithUpdatedDeposit"
                ],
                [
                    "uint32",
                    "depositId",
                    "UUID of deposit to be sped up"
                ],
                [
                    "address",
                    "updatedRecipient",
                    "New recipient of deposit."
                ],
                [
                    "bytes",
                    "updatedMessage",
                    "Updated data that is sent to updatedRecipient. As described in section above, this should be set to 0x for the forseeable future."
                ],
                [
                    "bytes",
                    "depositorSignature",
                    "Signed message containing contents here"
                ]
            ]
        ],
        "code_blocks": [],
        "summaries": []
    },
    "https://docs.across.to/developer-docs/developers/running-a-relayer": {
        "title": "Running a Relayer | Across Docs",
        "headers": [
            "Running a Relayer",
            "Requirements",
            "Installation",
            "Updating",
            "Configuration",
            "Notes on requirements to RPC Providers",
            "Using a Redis in-memory database to improve performance",
            "Managing cross chain inventory",
            "Security Considerations",
            "Running the Relayer for the first time",
            "Which account will be used to send transactions?",
            "Which tokens can be relayed?",
            "How can I learn more about the code behind the bot's logic?",
            "Auxiliary Topics:",
            "Across V2 smart contracts",
            "Across V2 UMIP",
            "Additional relayer FAQs:",
            "How do Relayers get refunded?",
            "What is a root bundle?",
            "How often do new root bundles get published and executed?"
        ],
        "paragraphs": [
            "Technical instructions that someone comfortable with command line can easily follow to run their own Across V2 relayer",
            "",
            "All of the code in this repository can be found in this GitHub repository.",
            "The Across v2 Relay Bot is implemented in Node.js and is capable of running on a variety of platforms. See the following table for platform recommendations.",
            "CPU",
            "64-bit Dual Core @ 2+ GHz",
            "RAM",
            "4GB",
            "OS",
            "UNIX-like (GNU/Linux, MacOS)",
            "A helper script is available to automate updates. This performs the following actions:",
            "Flushes any existing installed dependencies.",
            "Pulls down the latest relayer-v2 commit.",
            "Installs all dependencies and builds the relayer.",
            "Displays the latest commit in the relayer-v2 repository.",
            "This update helper is offered as a convenience. After update, the operator must manually verify that the update succeeded and that the commit shown matches the intended target.",
            "This section describes the environment variable configuration that the bot requires in order to operate. This is the minimum configuration for running a relayer that operates on all supported tokens for all destination chains. You just need to change the configs at the top.",
            "Operators can exclude tokens/destination chains by not having a balance for that token on that destination chain. For customizing tokens/destination chains while having balances, see the advanced section for all supported configs.",
            "The relayer is dependent on querying historical blocks on each chain. The RPC provider must therefore support making archive queries. If the RPC provider cannot service archive queries then the relayer will fail with reports of obscure RPC errors.",
            "The relayer queries a lot of events from each chain's RPC that Across supports. Therefore, we use an in-memory database to improve performance and cache repeated RPC requests. Installation instructions can be found here. Once installed, run redis-server in one terminal window and then open another one to continue running the relayer from.",
            "The redis server is used to cache the responses of RPC-intensive repetitive requests, like eth_getLogs, or internally-computed data like getBlockForTimestamp. Caching of data is subject to the age of the input response from the RPC provider, such that a minimum block age is required before it will be retained. This provides some protection against caching invalid data, or valid data becoming invalid (or otherwise changing) due to chain forks/re-orgs.",
            "The relayer bot is designed to use the same account across each of the supported chains: Ethereum, Optimism, Polygon, Boba and Arbitrum. Therefore, the bot can be told to automatically rebalance its inventory across chains and target some allocation.",
            "The best way to demonstrate how rebalancing can be customized is to walk through an example setting of the RELAYER_INVENTORY_CONFIG environment variable:",
            "First let's look at the \"tokenConfig\". This informs the relayer how it should distribute its token balances across the different networks. Each of the keys of the \"tokenConfig\" object (\"0xC02\", \"0x6B1\", \"0xA0b\", \"0x226\") represent the Mainnet address of the ERC20 token that we want to automatically control inventory for. So, in order, the tokens in the example config are WETH, DAI, USDC, and WBTC. ",
            "Diving into WETH's token configuration, notice that it has an object containing \"targetPct\", \"thresholdPct\", \"unwrapWethThreshold\", and \"unwrapWethTarget\" mapped to each network ID. The \"targetPct\" and \"thresholdPct\" instructs the relayer account on Mainnet when to send funds to the network with the associated network ID. ",
            "The relayer is always aware of its aggregate funds across all chains, so for example if the account has 10 WETH on Mainnet, 5 on Optimism, 4 on Arbitrum, 3 on Polygon, and 2 on BOBA, then it has a total of 24 WETH. The allocations are: 5/24 on Optimism, 4/24 on Arbitrum, etc.",
            "When the relayer's allocation for a specific chain drops below the \"thresholdPct\", then the relayer will send funds from its Mainnet account to the chain with the shortfall so that its post-transfer allocation is increased to the \"targetPct\". In the example config above, if the allocation percent on Optimism were to drop below 5%, then the relayer would send funds from Mainnet to Optimism to bring its allocation to 8%.",
            "All funds are sent through the canonical L1-->L2 bridges and the logic implementing such rebalances can be found here.",
            "Note that the \"targetPct\" and \"thresholdPct\" are unused for the mainnet token config (i.e. for the row with ID \"1\") but are included to avoid a compile-time error.",
            "By default, all fills sent by the relayer are set to be repaid on Mainnet, so if the relayer sent a fill on Polygon for USDC, then it will receive the relayed USDC amount plus a relayer fee on Mainnet. This means that over time, the relayer's allocation percent on Polygon will decrease.",
            "Therefore, the inventory rebalance logic also provides a function that overrides the repayment chain ID to try to maintain its target allocation. This happens automatically before submitting any fill by this function.",
            "The \"unwrapWethThreshold\" and \"unwrapWethTarget\" tell the relayer when to unwrap WETH into ETH to keep enough ETH on hand for paying gas costs. These configs are unused on Polygon which does not pay gas in ETH. Moreover, these configs should only be set in the token configuration for WETH (i.e. \"0xC02aaA39b223FE8D0A0e5C4F27eAD9083C756Cc2\").",
            "If the relayer's ETH balance drops below the \"unwrapWethThreshold\", then it will unwrap enough WETH to increase its ETH balance to the \"unwrapWethTarget\" value.",
            "This logic can be found here.",
            "Wrap ETH",
            "The \"wrapEtherThreshold\" is used only for Optimism and Boba, the two OVM networks which requires that ETH, not WETH, is sent over the bridge from L2 to L1. Because of this fact, the relayer can end up holding a lot of ETH on L2 and not enough WETH. ",
            "If the relayer account's ETH balance on Optimism or Boba drops below this value, then it will wrap any excess ETH above the value into WETH. Its important that this value is set higher than the \"unwrapWethTarget\" for WETH for Optimism and Boba. In the example above, the \"unwrapWethTarget/Threshold\" is 1.5/0.75 and the \"wrapEtherThreshold\" is 2, meaning that the relayer on Optimism and Boba will unwrap WETH if its ETH balance is less than 0.75 and increase its balance to 1.5, and will wrap ETH if its balance is above 2.",
            "Logic for wrapping ETH can be found here.",
            "This description describes a basic set of security considerations that relay bot operators should be aware of. See Recommendations for suggestions on how to improve the security of relay bot instances.",
            "This is not a complete security guide. Relay bot operators solely assume the risk of loss of fu",
            "The Across v2 relay bot communicates with various public RPC endpoints, and thus requires outbound network access. Unknown/untrusted network actors may be able to communicate with the relay bot host. It's important to reduce the attack surface area that the host environment exposes, in terms of:",
            "Network services listening on public interfaces.",
            "Interfaces opened for remote administration, and their permitted authentication mechanisms.",
            "Third-party installations that may autonomously communicate (i.e. phone home) over the network.",
            "The Across relay bot requires an in-memory copy of an Ethereum private key in order to sign relay transactions. This in-memory copy is typically loaded from the execution environment, via the following environment variables:",
            "MNEMONIC (when run with --wallet mnemonic)",
            "PRIVATE_KEY (when run with --wallet privateKey)",
            "When not specified directly via environment variables, these configuration items can be saved in the filesystem in a .env file, in the relayer-v2 working directory. Relay bot operators should be aware of at least the following:",
            "Depending on the .env mode flags, users or programs with filesystem access may be able to read secrets from the .env file.",
            "When storing secrets on disk, anyone with raw disk access may be able to override filesystem permissions and recover file contents. This includes:",
            "People with system administrative privileges.",
            "People with physical disk/hardware access.",
            "Vendors of cloud-based execution environments (i.e. VM hosts).",
            "During operation, the relayer-v2 bot retains secret keying information in-memory. Anyone with the ability to dump application or system memory may be able to retrieve secret keying material.",
            "The Across relay bot supports a bespoke Google Cloud key management interface (gckms), whereby the bot retrieves keying material from a secured, trusted key management. Keying material retrieved over the gckms interface is stored locally in-memory, but is not saved to disk.",
            "The gckms interface is tailored for use by Risk Labs and is not currently intended for use by third-party bot operators. Support for generic third-party key management systems may be added to the relay bot in future.",
            "Deploy relay bot instances in isolated environments (i.e. dedicated VM/container environment, or dedicated hardware).",
            "Adhere to basic system administration and hardening practices. NIST 800-123 Guide to General Server Security may be useful.",
            "Never install software from untrusted sources, and verify software packages before installation/execution.",
            "Limit the ability for malicious network actors to gain system access by restricting inbound network traffic to trusted hosts and/or services. Drop all other traffic.",
            "Avoid the use of password-based authentication schemes for remote login services. Use key-based authentication (i.e. SSH keys) instead.",
            "Ensure that filesystem ownership and permission flags are set appropriately at all times. These attributes should be periodically reviewed for correctness.",
            "Ensure that parties with raw disk access are trusted.",
            "Note: Where untrusted or unknown parties may have raw disk access, filesystem encryption schemes may be useful in reducing the opportunity for theft of secret keying material.",
            "Ensure that parties with the ability to dump system and/or application memory are trusted.",
            "Note: This applies primarily to vendors providing virtualised execution environments - i.e. cloud/VM hosts.",
            "Maintain at least one secure offline copy (backup) of the secret keying material. Backups should be periodically reviewed for correctness.",
            "Once you've installed and built the relayer code and set your desired environment variables, you're all set to run the relayer code. The entry point to run the code is the command (choose one of the following):",
            "This will run the relayer in \"simulation mode\" meaning that it will simulate the transactions that would fill deposits, but will not submit them. This will give you a chance to review transactions before funds are sent. ",
            "On the first run, the bot should approve various SpokePool contracts to withdraw ERC20's from it. This is required to fulfill relays. These approval transactions are not \"simulated\" currently and will still be sent even when running in simulation mode. Approvals will only be sent for tokens with nonzero balances in the relayer account.",
            "If the bot successfully completes a run, you will see this log before it exits: ",
            "When you feel ready to run the relayer and send your first relay, set SEND_RELAYS=true to exit simulation mode!",
            "The first account associated with the MNEMONIC set in the environment will be used. Be sure to add ETH and any token balances to its account so that it can send relays.",
            "WETH, USDC, DAI, WBTC, UMA. This list is likely to require updates in the future. Work is being done to automate the latest token list.",
            "The relayer's entry point file is Relayer/index.ts.",
            "The relayer bot first identifies all unfilled deposits across each of the chains. Deposit events are fetched here by the SpokePoolClient for each chain. Using these unfilled deposits as input, the relayer will attempt to fill them based if it has the token balance on the destination chain to do so.",
            "The smart contracts can be found at this repository. They have been audited by OpenZeppelin. A high level video overview of the contract architecture can be found here.",
            "UMIP-157 explains how \"valid\" relays are identified, which are relays that correctly filled a deposit and paid the correct fees and are due to be returned their relayed amount plus a relay fee.",
            "The relayer bot code is supposed to be one implementation of UMIP-157.",
            "Relayers are paid back after a root bundle containing the relayer‚Äôs fulfillment is published to mainnet and passes a challenge period. Relayers can choose which chains they are paid back on. When running the example relayer code, they are by default repaid on the chain that they fulfill deposits on. The relayer can override this setting.",
            "A root bundle for a block range is a set of three Merkle roots that contains all of the information necessary to refund relayers who fulfilled a deposit during the block range. A root bundle is valid only if it contains all of the expected information for a block range. This UMIP explains at length exactly how to construct a valid root bundle.",
            "The current liveness period is 7200 seconds or 2 hours. You can always query it on the HubPool by calling the read-only method liveness(), and only one root bundle can be proposed at a time. So, the fastest cadence for root bundles being proposed is every 2 hours. Each root bundle contains approximately all of the relayer refunds up to the current time (as of the proposal) and as old as right after the preceding root bundle proposal time. A 'dataworker' is what we refer to as the agent who gathers all Fill and Deposit events from all of the chains that Across V2 supports bridging to and from in order to construct these Merkle root bundles. A dataworker could choose to propose a new root bundle right after the current one passes liveness, or it can choose to wait. Realistically, we expect that a dataworker will only submit a new root bundle after it contains a certain volume of refunds, for capital efficiency reasons. So to summarize:",
            "Relayer refunds are contained in root bundles that are optimistically published to the HubPool",
            "Once the root bundle proposal passes liveness, refunds can be sent to relayers. At this point, relayers are made whole and receive an additional relayer fee",
            "The fastest cadence of root bundle proposals is once every two hours. In the worst case, root bundles can take much longer if volume is low across the system",
            "A dataworker can propose a bundle at any time. However, if a current bundle is in liveness - it is required that either that bundle be disputed or the bundle passes liveness and is executed before a new bundle is proposed.",
            "",
            "",
            "Last updated 8 months ago"
        ],
        "lists": [
            "How Across Works\nOverview\nRoles within Across\nFee Model\nValidating Root Bundles\nDisputing Root Bundles\nDevelopers\nAcross API\nAcross SDK\nContract Addresses\nMainnet (Chain ID: 1)\nArbitrum (Chain ID: 42161)\nOptimism (Chain ID: 10)\nBase (Chain ID: 8453)\nzkSync (Chain ID: 324)\nPolygon (Chain ID: 137)\nSelected Contract Functions\nRunning a Relayer\nIntegrating Across into your application\nComposable Bridging\nDeveloper notes\nMigration from V2 to V3\nADDITIONAL INFO\nSupport Links\nBug Bounty\nAudits",
            "Overview\nRoles within Across\nFee Model\nValidating Root Bundles\nDisputing Root Bundles",
            "Roles within Across\nFee Model\nValidating Root Bundles\nDisputing Root Bundles",
            "Across API\nAcross SDK\nContract Addresses\nMainnet (Chain ID: 1)\nArbitrum (Chain ID: 42161)\nOptimism (Chain ID: 10)\nBase (Chain ID: 8453)\nzkSync (Chain ID: 324)\nPolygon (Chain ID: 137)\nSelected Contract Functions\nRunning a Relayer\nIntegrating Across into your application\nComposable Bridging\nDeveloper notes\nMigration from V2 to V3",
            "Mainnet (Chain ID: 1)\nArbitrum (Chain ID: 42161)\nOptimism (Chain ID: 10)\nBase (Chain ID: 8453)\nzkSync (Chain ID: 324)\nPolygon (Chain ID: 137)",
            "Support Links\nBug Bounty\nAudits",
            "Requirements\nInstallation\nUpdating\nConfiguration\nNotes on requirements to RPC Providers\nUsing a Redis in-memory database to improve performance\nManaging cross chain inventory\nSecurity Considerations\nRunning the Relayer for the first time\nWhich account will be used to send transactions?\nWhich tokens can be relayed?\nHow can I learn more about the code behind the bot's logic?\nAuxiliary Topics:\nAcross V2 smart contracts\nAcross V2 UMIP\nAdditional relayer FAQs:\nHow do Relayers get refunded?\nWhat is a root bundle?\nHow often do new root bundles get published and executed?",
            "Flushes any existing installed dependencies.\nPulls down the latest relayer-v2 commit.\nInstalls all dependencies and builds the relayer.\nDisplays the latest commit in the relayer-v2 repository.",
            "Network services listening on public interfaces.\nInterfaces opened for remote administration, and their permitted authentication mechanisms.\nThird-party installations that may autonomously communicate (i.e. phone home) over the network.",
            "MNEMONIC (when run with --wallet mnemonic)\nPRIVATE_KEY (when run with --wallet privateKey)",
            "Relayer refunds are contained in root bundles that are optimistically published to the HubPool\nOnce the root bundle proposal passes liveness, refunds can be sent to relayers. At this point, relayers are made whole and receive an additional relayer fee\nThe fastest cadence of root bundle proposals is once every two hours. In the worst case, root bundles can take much longer if volume is low across the system\nA dataworker can propose a bundle at any time. However, if a current bundle is in liveness - it is required that either that bundle be disputed or the bundle passes liveness and is executed before a new bundle is proposed."
        ],
        "tables": [
            [
                [
                    "Resource",
                    "Recommended"
                ],
                [
                    "CPU",
                    "64-bit Dual Core @ 2+ GHz"
                ],
                [
                    "RAM",
                    "4GB"
                ],
                [
                    "OS",
                    "UNIX-like (GNU/Linux, MacOS)"
                ]
            ]
        ],
        "code_blocks": [
            {
                "id": "6d6e5e39786745f7b116710fc81f9f09",
                "code": "# Clone relayer code with Github CLI or git clone.\ngit clone https://github.com/across-protocol/relayer-v2.git\ncd relayer-v2\n\n# Establish environment file and restrict filesystem permissions.\ntouch .env\nchmod 0600 .env\n\n# The private key or seed phrase for the relayer can be stored in a\n# dedicated file. Operators should be especially careful to set the file\n# permissions correctly and to backup any secrets securely. The path to\n# the secret is set via the SECRET env var (optionally specified in\n# .env). The file may be stored anywhere in the file system but must be\n# readable by the user that runs the relayer.\ntouch .secret\nchown <user>:<group> .secret\nchmod 0600 .secret\necho <private-key-or-mnemonic> > .secret\nchmod 0400 .secret\n\n# Install dependencies and build relayer.\n# Nodejs and yarn are required.\nyarn install\nyarn build\n\n# Run unit tests.\nyarn test\n\n# Apply any necessary changes to .env and mark it read-only.\nchmod 0400 .env"
            },
            {
                "id": "71dfd61e1bfb47e4b70f8ed580a9506f",
                "code": "yarn update"
            },
            {
                "id": "ffd34a5f1b3c4e75b17df4202686db1b",
                "code": "# Do change the following configs:\n\n# Amount of time to wait (in seconds) between bot loops. This can be\n# set to 0 to run once and exit (recommended). Operators can schedule\n# relayer externally (i.e. via cron or another job scheduler).\n#\n# If set to a non-zero value such as 10, the bot will run through all\n# instructions, sleep for 10 seconds, then run again. This mode is not\n# recommended.\nPOLLING_DELAY=0\n\n# SECRET identifies a separate file containing a private key or mnemonic\n# to be used by the relayer. The file must contain only the raw key or\n# mnemonic. Critical: Ensure that the filesystem permissions for this\n# file are properly configured (i.e. owned by one specific user, not\n# world-readable, ...).\n# SECRET=<path-to-private-key-or-mnemonic>\nSECRET=.secret\n\n# Define RPC providers for each chain. One RPC provider is specified\n# per line. Format:\n# RPC_PROVIDER_<PROVIDER-NAME>_<CHAIN-ID>=<ENDPOINT-URL>\nRPC_PROVIDER_INFURA_1=https://mainnet.infura.io/v3/...\nRPC_PROVIDER_INFURA_10=https://optimism-mainnet.infura.io/v3/...\n# Repeat this for each supported chain (1, 10, 137, 42161, ...)\n\nRPC_PROVIDER_ALCHEMY_1=https://eth-mainnet.g.alchemy.com/v2/...\n# Repeat this for each supported chain (1, 10, 137, 42161, ...)\n\n# Specify RPC provider preferences. The first provider is always used.\n# Subsequent providers are used as backups in event of a higher\n# priority provider being unavailable, or failing quorum. If\n# NODE_QUORUM is > 1, there must be at least NODE_QUROUM number of\n# providers defined, and some RPC queries will be performed against\n# NODE_QUORUM number of providers in parallel.\nRPC_PROVIDERS=INFURA,ALCHEMY\n\n# Per-chain overrides are possible. In the example below, LlamaNodes\n# is preferred on Ethereum and Polygon.\nRPC_PROVIDERS_1=LLAMANODES,INFURA,ALCHEMY\nRPC_PROVIDERS_137=LLAMANODES,INFURA,ALCHEMY\n\n# Enable on-chain relayer functionality. This is disabled by default\n# and must be explicitly enabled for the relayer to send transactions.\n# This can be used to run bot in \"simulation mode\". To turn bot on,\n# set to \"true\".\nSEND_RELAYS=false\n\n# Deposit lookback window, specified in seconds. This is subtracted\n# from the current time and is resolved to a block number on each\n# chain, effectively controlling how far back in time the relayer\n# will scan for unfilled deposits. \nMAX_RELAYER_DEPOSIT_LOOK_BACK=1800\n\n# Gas fees are difficult to estimate correctly, and the strategy for\n# setting  gas might depend on the priorities of the relay bot operator.\n# Gas fees can therefore be scaled on each chain. Note that `ethers` is\n# used for sourcing gas estimates, and it can supply a default value of\n# 1.5 Gwei for priority fees. This is notably seen on Optimism (chainId\n# 10), and can lead to overpriced transactions. Operators are encouraged\n# to tune these scalers to meet their own needs and risk profile.\nMAX_FEE_PER_GAS_SCALER_10=1.2\nPRIORITY_FEE_SCALER_10=0.1\n\n#### Do not change the configs below without checking with the Across team #####\n#### Or unless you strongly know what you're doing\n\n# A Redis in-memory DB can drastically speed up the performance\n# of the bot. This is technically not required, but reduces the\n# instance of repeated network queries and therefore reduces\n# the time and network bandwidth required for successful relay\n# bot operation.\n# Install redis and then ensure that redis-server is started:\n#     https://redis.io/docs/getting-started/\n# Under the hood, the relayer will cache JSON-rpc request data\n# from requests like `eth_getBlock` in the Redis DB.\nREDIS_URL=\"redis://127.0.0.1:6379\""
            },
            {
                "id": "4b949e1b930049f4bfd6af7f72fd5e0e",
                "code": "# The NODE_MAX_CONCURRENCY environment variable controls the\n# maximum number of concurrent requests can be issued to a\n# single RPC provider. Per-chain overrides are possible by\n# appending _<chainID>=<value>. In the event that rate-limiting\n# is occurring (429 responses to RPC requests) then concurrency\n# can be reduced as an alternative to upgrading the RPC provider\n# subscription/quota. In the example below, the global default\n# is set to 25, and is overridden to 40 for Ethereum.\nNODE_MAX_CONCURRENCY=25\nNODE_MAX_CONCURRENCY_1=40\n\n# The relayer can be configured to require a minimum return on\n# capital outlaid when filling relays. This minimum return is\n# specified as a multiplier of the amount to be allocated to each\n# fill. Minimum fees can also be configured per token(symbol)/route\n# combination. Examples:\n# Require 1 bps as the global default (unless overridden).\nMIN_RELAYER_FEE_PCT=0.0001\n# Override: Require at least 1.5 bps on USDC from Arbitrum to Ethereum.\nMIN_RELAYER_FEE_PCT_USDC_42161_1=0.00015\n# Override: Require at least 0.8 bps on WETH from Optimism to Arbitrum.\nMIN_RELAYER_FEE_PCT_WETH_10_42161=0.00008\n\n# The caching duration for a subset of the queries issued to RPC\n# providers can be configured. The default time-to-live (TTL) of\n# queries is 3600 seconds (60 minutes). This is set conservatively to\n# refresh the cache often, so as to ensure that any incomplete or\n# invalid RPC provider responses are ejected within the short term.\n# Increasing cache TTL may improve the speed of the bot and lead to\n# reduced RPC provider quota utilisation, at the cost of increased\n# resource usage (i.e. RAM + disk). Increasing cache TTL may also\n# provide additional exposure to invalid or incomplete RPC responses.\nPROVIDER_CACHE_TTL=3600\n\n# Minimum number of block confirmations (MDC) for a Deposit event\n# before a relay bot will consider the Deposit finalised and\n# valid. The MDC is set based on the total deposit USD volume in a\n# relayer iteration and is specific to an origin chain. For example,\n# if the relayer wants to fill $1000 of deposits originating from mainnet,\n# then it will wait until a deposit is 32 blocks past HEAD before \n# it sends a fill. If the relayer wants to fill $100 of deposits, then it will\n# wait 16 blocks. Users can tweak these settings and take on more finality risk\n# in exchange for reacting to deposits more quickly. The following configuration\n# is equal to the default (i.e. the following config will be used if\n# MIN_DEPOSIT_CONFIRMATIONS is not set. Finality assurances may change over time. \n# See code comments here for more details about the risks with modifying\n# this configuration: https://github.com/across-protocol/relayer-v2/blob/0dde90a5909ce4ddc0dfb27e1ec8bcc1d75e2e25/src/common/Constants.ts#L25\nMIN_DEPOSIT_CONFIRMATIONS='{\"1000\": \"{ \"1\": 32, \"10\": 0, \"137\": 100, \"42161\": 0 }\", \"100\": \"{ \"1\": 16, \"10\": 0, \"137\": 80, \"42161\": 0 }\" }'\n\n# List of tokens that the relayer supports. These are addresses\n# on Ethereum.\n# For example, if only USDC's address is specified, the relayer\n# would only fill transfers of USDC going to any chains (unless\n# overridden by RELAYER_DESTINATION_CHAINS).\n# If RELAYER_TOKENS is not set or set to [], the relayer will fill\n# transfers of any token.\nRELAYER_TOKENS='[\"0xC02aaA39b223FE8D0A0e5C4F27eAD9083C756Cc2\", \"0xA0b86991c6218b36c1d19D4a2e9Eb0cE3606eB48\", \"0x2260FAC5E5542a773Aa44fBCfeDf7C193bc2C599\"]'\n\n# List of destination chains the relayer supports. If set to a\n# non-empty list, only transfers going to these chains will be\n# filled. In the example below, transfers destined for Ethereum\n# will be ignored.\nRELAYER_DESTINATION_CHAINS='[10,137,42161]'\n\n# By default set to false. If false, the relayer will ignore\n# any deposits that it cannot fully fill. A feature for partial\n# fills is not implemented yet but its possible to do so at the\n# contract level. If this is set to true, then the relayer will\n# fill 1 wei of the deposited amount which will trigger a slow\n# fill payment to be sent from HubPool to SpokePool. There is no\n# benefit to do this, # and the system will function correctly\n# as long as one relayer is sending slow relays. We recommend\n# that you leave this value set to \"false\".\nSEND_SLOW_RELAYS=false\n\n# This inventory config will be explained in a separate section\n# but generally this informs the relayer how it should rebalance\n# token inventories across chains. The following simple example\n# tells the bot that it should target holding 8% of its WETH on\n# chain 10, 8% on chain 42161, 8% on chain 137, 0.2% on chain\n# 288, and the remainder on Mainnet. The config can also be used\n# to specify how much ETH versus WETH to hold.\nRELAYER_INVENTORY_CONFIG='{\"tokenConfig\":{\"0xC02aaA39b223FE8D0A0e5C4F27eAD9083C756Cc2\":{\"1\":{\"targetPct\":100,\"thresholdPct\":100,\"unwrapWethThreshold\":3.5,\"unwrapWethTarget\":5},\"10\":{\"targetPct\":8,\"thresholdPct\":5,\"unwrapWethThreshold\":0.75,\"unwrapWethTarget\":1.5},\"137\":{\"targetPct\":8,\"thresholdPct\":5},\"288\":{\"targetPct\":0.2,\"thresholdPct\":0.1,\"unwrapWethThreshold\":0.65,\"unwrapWethTarget\":1},\"42161\":{\"targetPct\":8,\"thresholdPct\":5,\"unwrapWethThreshold\":0.75,\"unwrapWethTarget\":1.5}}}}'\n\n# Defaults to 1, must be set >= 1. If set > 1, then for any RPC\n# request, this requires that at least this count of RPCs\n# specified in the NODE_URLS_[ID] list return the exact same\n# response. We recommend setting this to 2 so that the relayer\n# does not accidentally relay a deposit whose properties two\n# different RPCs disagree about. This edge case is rare but\n# could lead to loss of funds.\nNODE_QUORUM=1"
            },
            {
                "id": "4e45d704b80b4aada64a9ae3973b88c7",
                "code": "\"RELAYER_INVENTORY_CONFIG\": {\n  \"tokenConfig\": {\n     \"0xC02aaA39b223FE8D0A0e5C4F27eAD9083C756Cc2\": {\n        \"1\": { \"targetPct\": 100, \"thresholdPct\": 100, \"unwrapWethThreshold\": 3.5, \"unwrapWethTarget\": 5 },\n        \"10\": { \"targetPct\": 8, \"thresholdPct\": 5, \"unwrapWethThreshold\": 0.75, \"unwrapWethTarget\": 1.5 },\n        \"137\": { \"targetPct\": 8, \"thresholdPct\": 5 },\n        \"288\": { \"targetPct\": 0.2, \"thresholdPct\": 0.1, \"unwrapWethThreshold\": 0.65, \"unwrapWethTarget\": 1 },\n        \"42161\": { \"targetPct\": 8, \"thresholdPct\": 5, \"unwrapWethThreshold\": 0.75, \"unwrapWethTarget\": 1.5 }\n      },\n      \"0x6B175474E89094C44Da98b954EedeAC495271d0F\": {\n        \"10\": { \"targetPct\": 8, \"thresholdPct\": 5 },\n        \"137\": { \"targetPct\": 8, \"thresholdPct\": 5 },\n        \"288\": { \"targetPct\": 0.2, \"thresholdPct\": 0.1 },\n        \"42161\": { \"targetPct\": 8, \"thresholdPct\": 5 }\n      },\n      \"0xA0b86991c6218b36c1d19D4a2e9Eb0cE3606eB48\": {\n        \"10\": { \"targetPct\": 8, \"thresholdPct\": 5 },\n        \"137\": { \"targetPct\": 8, \"thresholdPct\": 5 },\n        \"288\": { \"targetPct\": 0.2, \"thresholdPct\": 0.1 },\n        \"42161\": { \"targetPct\": 8, \"thresholdPct\": 5 }\n      },\n      \"0x2260FAC5E5542a773Aa44fBCfeDf7C193bc2C599\": {\n        \"10\": { \"targetPct\": 8, \"thresholdPct\": 5 },\n        \"137\": { \"targetPct\": 8, \"thresholdPct\": 5 },\n        \"288\": { \"targetPct\": 0.2, \"thresholdPct\": 0.1 },\n        \"42161\": { \"targetPct\": 8, \"thresholdPct\": 5 }\n      }\n  },\n  \"wrapEtherThreshold\": 2\n}"
            },
            {
                "id": "cf6697ff83bd4b0ebe6a3691fd5073e7",
                "code": "# Run the relayer, deriving private key from the SECRET env var (default)\nSEND_RELAYS=false yarn relay\n\n# Run the relayer, overriding the private key source.\n# Sub in the desired key source (secret, mnemonic, privateKey, gckms).\nSEND_RELAYS=false yarn relay --wallet <secret|mnemonic|privateKey|gckms>"
            },
            {
                "id": "5864bb542d9c4b92a5256c38a0f6d89c",
                "code": "[debug]: {\n  \"at\": \"Relayer#index\",\n  \"message\": \"End of serverless execution loop - terminating process\"\n}"
            }
        ],
        "summaries": []
    },
    "https://docs.across.to/developer-docs/developers/integrating-across-into-your-application": {
        "title": "Integrating Across into your application | Across Docs",
        "headers": [
            "Integrating Across into your application",
            "How to initiate a deposit",
            "How to track a deposit",
            "How to speed up a deposit that is taking a long time to be picked up by a relayer",
            "Using the API versus SDK to construct deposit parameters",
            "Commonly asked questions"
        ],
        "paragraphs": [
            "Instructions and examples for calling the smart contract functions that would allow third party projects to transfer assets across EVM networks.",
            "Across was designed as a platform on which third party projects enabling cross chain asset transfer could be built. We are very excited to build together and we've put together this guide which should contain everything you need to integrate with Across.",
            "If you have further questions or suggestions for this guide, please send a message to the #developer-questions channel in the Across Discord.",
            "Deposits are initiated from contracts called \"SpokePools\" deployed on any supported EVM. For example, on Ethereum the contract is named \"Ethereum_SpokePool.sol\"_, and on Optimism the contract is named \"Optimism_SpokePool.sol\".",
            "Spoke pool addresses can be found here.",
            "Deposits are triggered via the SpokePool contract's deposit function, whose parameters are explained in detail here. This documentation also explains how to populate parameters like relayerFeePct and quoteTime.",
            "Here is a deposit sent on Optimism. Here is a deposit on Ethereum",
            "Deposit and corresponding fill events are conveniently scraped by a database and displayed here.",
            "The database implementation can be found in this repository.",
            "The lower a deposit's relayer fee %, the less relayers are incentivized to fulfill it. While a deposit is not fully filled, its relayer fee % can be increased by calling speedUpDeposit.",
            "We recommend using the API for the easiest way to query suggested deposit params.",
            "Can I use the Across SDK to submit contract transactions?",
            "Not yet, working on it!",
            "Last updated 10 months ago"
        ],
        "lists": [
            "How Across Works\nOverview\nRoles within Across\nFee Model\nValidating Root Bundles\nDisputing Root Bundles\nDevelopers\nAcross API\nAcross SDK\nContract Addresses\nMainnet (Chain ID: 1)\nArbitrum (Chain ID: 42161)\nOptimism (Chain ID: 10)\nBase (Chain ID: 8453)\nzkSync (Chain ID: 324)\nPolygon (Chain ID: 137)\nSelected Contract Functions\nRunning a Relayer\nIntegrating Across into your application\nComposable Bridging\nDeveloper notes\nMigration from V2 to V3\nADDITIONAL INFO\nSupport Links\nBug Bounty\nAudits",
            "Overview\nRoles within Across\nFee Model\nValidating Root Bundles\nDisputing Root Bundles",
            "Roles within Across\nFee Model\nValidating Root Bundles\nDisputing Root Bundles",
            "Across API\nAcross SDK\nContract Addresses\nMainnet (Chain ID: 1)\nArbitrum (Chain ID: 42161)\nOptimism (Chain ID: 10)\nBase (Chain ID: 8453)\nzkSync (Chain ID: 324)\nPolygon (Chain ID: 137)\nSelected Contract Functions\nRunning a Relayer\nIntegrating Across into your application\nComposable Bridging\nDeveloper notes\nMigration from V2 to V3",
            "Mainnet (Chain ID: 1)\nArbitrum (Chain ID: 42161)\nOptimism (Chain ID: 10)\nBase (Chain ID: 8453)\nzkSync (Chain ID: 324)\nPolygon (Chain ID: 137)",
            "Support Links\nBug Bounty\nAudits",
            "How to initiate a deposit\nHow to track a deposit\nHow to speed up a deposit that is taking a long time to be picked up by a relayer\nUsing the API versus SDK to construct deposit parameters\nCommonly asked questions",
            "Can I use the \nAcross SDK\n to submit contract transactions?\nNot yet, working on it!",
            "Not yet, working on it!"
        ],
        "tables": [],
        "code_blocks": [],
        "summaries": []
    },
    "https://docs.across.to/developer-docs/developers/composable-bridging": {
        "title": "Composable Bridging | Across Docs",
        "headers": [
            "Composable Bridging",
            "What is Composable Bridging:?",
            "How does it work? ",
            "Requirements ",
            "Detailed instructions",
            "Example: Implementing a Bridge and Unwrap"
        ],
        "paragraphs": [
            "Use Across to bridge + execute a transaction",
            "You can instruct Across to execute a transaction upon filling your deposit on the destination chain. This transaction would be executed atomically with the fill transaction.",
            "NOTE: The transaction that gets executed on the destination chain must be non-reverting otherwise user deposits may risk getting locked.",
            "When a relayer fills your deposit by calling fillRelay() on the destination SpokePool, if the deposit has a message attached, then the SpokePool will attempt to call handleAcrossMessage() on your recipient address and pass in the following params: ",
            "handleAcrossMessage(address tokenSent, uint256 amount, bool fillCompleted, address relayer, bytes memory message)",
            "The deposit message is not empty",
            "The recipient address is a contract on the destinationChainId that implements a public handleAcrossMessage(address,uint256,bool,address,bytes) function, and this function must be non-reverting ",
            "The additional gas cost to execute the above function is compensated for in the deposit's relayerFeePct",
            "Construct your message ",
            "Use the Across API to get an estimate of the relayerFeePct you should set for your message and recipient combination ",
            "Call deposit() passing in your message ",
            "Once the relayer calls fillRelay() on the destination, your recipient's handleAcrossMessage will be executed",
            "Imagine that I want to bridge ETH from Ethereum to Optimism and receive ETH, not wrapped WETH on Optimism",
            "I will deploy the following contract on Optimism which unwraps received WETH into ETH and sends to a designated owner EOA",
            "Call Across-API‚Äôs /suggested-fees endpoint with params ?token=0xWETH-on-ethereum-address&destinationChainId=10&amount= x&originChainId=1&recipient=MyUnwrapper.address&message=0x1234 ",
            "Here we set message to something useless but not-zero so that the destination SpokePool ultimately calls handleAcrossMessage on MyUnwrapper",
            "Last updated 10 months ago"
        ],
        "lists": [
            "How Across Works\nOverview\nRoles within Across\nFee Model\nValidating Root Bundles\nDisputing Root Bundles\nDevelopers\nAcross API\nAcross SDK\nContract Addresses\nMainnet (Chain ID: 1)\nArbitrum (Chain ID: 42161)\nOptimism (Chain ID: 10)\nBase (Chain ID: 8453)\nzkSync (Chain ID: 324)\nPolygon (Chain ID: 137)\nSelected Contract Functions\nRunning a Relayer\nIntegrating Across into your application\nComposable Bridging\nDeveloper notes\nMigration from V2 to V3\nADDITIONAL INFO\nSupport Links\nBug Bounty\nAudits",
            "Overview\nRoles within Across\nFee Model\nValidating Root Bundles\nDisputing Root Bundles",
            "Roles within Across\nFee Model\nValidating Root Bundles\nDisputing Root Bundles",
            "Across API\nAcross SDK\nContract Addresses\nMainnet (Chain ID: 1)\nArbitrum (Chain ID: 42161)\nOptimism (Chain ID: 10)\nBase (Chain ID: 8453)\nzkSync (Chain ID: 324)\nPolygon (Chain ID: 137)\nSelected Contract Functions\nRunning a Relayer\nIntegrating Across into your application\nComposable Bridging\nDeveloper notes\nMigration from V2 to V3",
            "Mainnet (Chain ID: 1)\nArbitrum (Chain ID: 42161)\nOptimism (Chain ID: 10)\nBase (Chain ID: 8453)\nzkSync (Chain ID: 324)\nPolygon (Chain ID: 137)",
            "Support Links\nBug Bounty\nAudits",
            "What is Composable Bridging:?\nHow does it work? \nRequirements \nDetailed instructions\nExample: Implementing a Bridge and Unwrap",
            "handleAcrossMessage(address tokenSent, uint256 amount, bool fillCompleted, address relayer, bytes memory message)",
            "The deposit \nmessage\n is not empty\nThe \nrecipient\n address is a contract on the destinationChainId that implements a public \nhandleAcrossMessage(address,uint256,bool,address,bytes) \nfunction, and this function must be non-reverting \nThe additional gas cost to execute the above function is compensated for in the deposit's \nrelayerFeePct",
            "Construct your \nmessage\n \nUse the Across API to get an estimate of the \nrelayerFeePct\n you should set for your message and recipient combination \nCall \ndeposit()\n passing in your message \nOnce the relayer calls \nfillRelay()\n on the destination, your recipient's \nhandleAcrossMessage\n will be executed",
            "Imagine that I want to bridge ETH from Ethereum to Optimism and receive ETH, not wrapped WETH on Optimism\nI will deploy the following contract on Optimism which unwraps received WETH into ETH and sends to a designated \nowner\n EOA",
            "Call Across-API‚Äôs \n/suggested-fees\n endpoint with params \n?token=0xWETH-on-ethereum-address&destinationChainId=10&amount= x&originChainId=1&recipient=\nMyUnwrapper\n.address&message=0x1234 \nHere we set \nmessage\n to something useless but not-zero so that the destination \nSpokePool\n ultimately calls \nhandleAcrossMessage\n on \nMyUnwrapper"
        ],
        "tables": [],
        "code_blocks": [
            {
                "id": "f8d5fd41629345d08d789926234ecc93",
                "code": "contract MyUnwrapper {\n    WETHInterface weth;\n    addess payable owner;\n    constructor() public {\n        owner = msg.sender;\n    }\n    function handleAcrossMessage(\n        address tokenSent, \n        uint256 amount, \n        bool, // fillCompleted unused\n        address, // relayer is unused \n        bytes memory // message is unused\n    ) external { \n        require(tokenSent == address(weth), \"received token not WETH\");\n        weth.withdraw(amount);\n        (bool sent, bytes memory data) = owner.call{value: amount}(\"\");\n        require(sent, \"Failed to send Ether\");\n    } \n}"
            }
        ],
        "summaries": []
    },
    "https://docs.across.to/developer-docs/developers/developer-notes": {
        "title": "Developer notes | Across Docs",
        "headers": [
            "Developer notes",
            "ETH/WETH Behavior",
            "More questions?"
        ],
        "paragraphs": [
            "This page includes a running list of Across behaviors that developers who are using Across should be aware of:",
            "Across liquidity pools are filled using WETH but, depending on the context, Across will sometimes send a user ETH and sometimes send a user WETH.",
            "If a bridge transfer is being sent to an EOA, the EOA will receive ETH (not WETH)",
            "If a bridge transfer is being sent to a contract, the contract will receive WETH (not ETH)",
            "If you are a developer working on integrating your project with Across, please reach out to us on Discord!",
            "We look forward to helping you integrate with the best bridge around!",
            "Last updated 1 year ago"
        ],
        "lists": [
            "How Across Works\nOverview\nRoles within Across\nFee Model\nValidating Root Bundles\nDisputing Root Bundles\nDevelopers\nAcross API\nAcross SDK\nContract Addresses\nMainnet (Chain ID: 1)\nArbitrum (Chain ID: 42161)\nOptimism (Chain ID: 10)\nBase (Chain ID: 8453)\nzkSync (Chain ID: 324)\nPolygon (Chain ID: 137)\nSelected Contract Functions\nRunning a Relayer\nIntegrating Across into your application\nComposable Bridging\nDeveloper notes\nMigration from V2 to V3\nADDITIONAL INFO\nSupport Links\nBug Bounty\nAudits",
            "Overview\nRoles within Across\nFee Model\nValidating Root Bundles\nDisputing Root Bundles",
            "Roles within Across\nFee Model\nValidating Root Bundles\nDisputing Root Bundles",
            "Across API\nAcross SDK\nContract Addresses\nMainnet (Chain ID: 1)\nArbitrum (Chain ID: 42161)\nOptimism (Chain ID: 10)\nBase (Chain ID: 8453)\nzkSync (Chain ID: 324)\nPolygon (Chain ID: 137)\nSelected Contract Functions\nRunning a Relayer\nIntegrating Across into your application\nComposable Bridging\nDeveloper notes\nMigration from V2 to V3",
            "Mainnet (Chain ID: 1)\nArbitrum (Chain ID: 42161)\nOptimism (Chain ID: 10)\nBase (Chain ID: 8453)\nzkSync (Chain ID: 324)\nPolygon (Chain ID: 137)",
            "Support Links\nBug Bounty\nAudits",
            "ETH/WETH Behavior\nMore questions?",
            "If a bridge transfer is being sent to an EOA, \nthe EOA will receive ETH\n (not WETH)\nIf a bridge transfer is being sent to a contract, \nthe contract will receive WETH\n (not ETH)"
        ],
        "tables": [],
        "code_blocks": [],
        "summaries": []
    },
    "https://docs.across.to/developer-docs/developers/migration-from-v2-to-v3": {
        "title": "Migration from V2 to V3 | Across Docs",
        "headers": [
            "Migration from V2 to V3",
            "Introduction",
            "Across API migration guide",
            "Overview",
            "Non-breaking changes",
            "Breaking changes (mid- to long-term)",
            "Changes to Across Smart Contracts",
            "Breaking Change: Across+ (Composable Bridging) ",
            "Events",
            "Important changes for Relayers",
            "Important changes for dApp Developers"
        ],
        "paragraphs": [
            "Information for users of the Across API and the smart contracts (e.g. those who call the Across SpokePools directly to deposit or fill bridge transfers and those who track SpokePool events).",
            "Across V2 is migrating in-place to V3 and will support cross-chain token swaps and a more streamlined contract interface. This guide is intended to help developers who integrate with Across to prepare their codebases for the upgrade. Please note that this page is a work in progress, and more sections will be added to help with different types of integrations.",
            "Across v3 redesigns how fees are handled when creating deposits. In a nutshell, the calculation of fees will be simplified and replaced byinputAmount/outputAmount arguments. This will impact the response data of the API and also how to call the deposit function of a SpokePool contract. Note that these changes won't be breaking short-term but are actionable mid- to long-term.",
            "For a seamless upgrade, there will be no breaking changes for the existing v2 interfaces.",
            "In Across v2, the request GET /suggested-fees returned",
            "It was then expected to call the method deposit of a SpokePool like",
            "The lpFeePct was not required as an argument and automatically derived based on the quoteTimestamp. But if you wanted to show the total bridge fee to the user, then you would have to sum them up like",
            "In Across v3, we need to pass the lpFeePct as part of the total fee when calling the deposit function. In order to be backwards-compatible, the API now returns for GET /suggested-fees",
            "There are no changes to the interface and therefore no changes are required for how you call the deposit function or calculate the total bridge fee. If you want to show the correct fee breakdown though, some changes are needed (see here).",
            "If you want to show the correct detailed fee breakdown, you can use the newly added v3 properties of the GET /suggested-fees response data",
            "Using the values of the new fees struct, you need to call the deposit function like",
            "Even though there are no actionable changes short-term, some change will be actionable mid- to long-term.",
            "The v2 deposit function will be deprecated and replaced by the depositV3 function. This new function has a different signature and does not expect a relayFeePct. Instead it requires an outputAmount",
            "In order to set the correct outputAmount, the caller needs to send a request GET /suggested-fees and subtract the returned fees from the inputAmount like",
            "As described here, the v3 fees have a different structure now. Eventually the redundant fields capitalFeePct, capitalFeeTotal, relayGasFeePct, relayGasFeeTotal and lpFeePct will be removed",
            "All users of Across+ (Composable Bridging) are required to upgrade their messaging implementations to use handleV3AcrossMessage().",
            "Across v3 updates the callback interface for receiving messages in a recipient contract. The new function prototype is as follows:",
            " The key differences to Across v2 are:",
            "handleAcrossMessage() -> handleV3AcrossMessage",
            "Function parameter `bool fillCompleted` has been removed.",
            "For a smooth transition to Across v3, integrators are recommended to implement concurrent support for handleAcrossMessage() and handleV3AcrossMessage(). handleAcrossMessage() can be removed at a later date.",
            "The motivation for updating the function prototype is that partial fills are no longer possible in Across v3, so messaging recipients no longer require special logic to account for them.",
            "If you depend on querying SpokePool events to track the status of bridge transfers, then this section is designed to support you.",
            "In Across V2, a bridge consists of a FundsDeposited event on the origin chain and a FilledRelay event on the destination chain. They must match on all common parameters and the FilledRelay#realizedLpFeePct must be equal to the LP fee at the FundsDeposited#quoteTimestamp based on the computation rules described in the UMIP. Moreover, the FilledRelay#destinationToken also needs to match the FundsDeposited#originToken based on the matching rules described in the UMIP.",
            "Across V3 bridge transfers consist of a V3FundsDeposited event emitted on the origin chain and a FilledV3Relay event emitted on the destination chain.",
            "V3FundsDeposited and FilledV3Relay must match on all common parameters except for outputToken. This can be set to 0x0 (the zero address) at deposit time to signal to relayers that they should use the \"equivalent\" token on the destinationChainId to fill the deposit, therefore if V3FundsDeposited#outputToken == 0x0 then FilledV3Relay#outputToken must be equal to the \"equivalent\" token on the destination chain. The Across UMIP should be updated to explain what it means to be \"equivalent\" but this essentially means the output and input token map to the same token on Ethereum, for example they could be the different USDC addresses on different L2s.",
            "Note that the amount transferred to the recipient is relayExecutionInfo.updatedOutputAmount",
            "This is an abridged summary of important breaking changes for Relayers to be aware of. ",
            "All deposits emitted in V3 contracts will be V3FundsDeposited events which can only be filled via SpokePool#filledV3Relay.",
            "The important changes here are:",
            "realizedLpFeePct The relayer no longer needs to set the realizedLpFeePct as a parameter when calling the fill function. LP fees will still be charged to relayers at refund time (i.e. they will receive the inputAmount minus the LP fees) and these fees will still be computed using the formula in the UMIP based on the deposit.quoteTimestamp. This is a nice quality of life improvement for relayers who will still need to compute the LP fee for a deposit but can use a much wider margin of error, as this fee will only be important for computing their profitability and they will not be at risk of sending an invalid fill if this fee is off by a small amount.",
            "outputToken: See the section above about how outputToken must be set if FundsDeposited#outputToken == 0x0. This should be set to the \"equivalent\" token for the destination chain in this case.",
            "No partial fills: it is not possible to send partial fills in V3.",
            "Slow fills: Slow fills will be requested via a new function requestSlowFill. Slow fills can only be requested on deposits where the inputToken and outputToken are \"equivalent\". Slow fills will pay out the inputAmount * realizedLpFeePct, which will be set as the slow fill's updatedOutputAmount",
            "The deposit interface will not change. The function will however emit a new event V3FundsDeposited as outlined in Across V3 Events. The fillDeadline will be set to MAX_UINT, meaning that the deposit will never expire and be refunded to the origin chain. The outputToken will be set to 0x0 to signal to depositors that the \"equivalent\" output token should be replaced at fill time. The exclusivityDeadline and exclusiveRelayer will be set to 0 and 0x0 respectively suggesting that there is no exclusivity period. Finally, the outputAmount will be equal to  inputAmount * (1 - relayerFeePct).",
            "To speed up a deposit, a new function will need to be used. Previously this was named speedUpDeposit and the new function to speed up a V3FundsDeposited event will be speedUpV3Deposit.",
            "Last updated 8 months ago"
        ],
        "lists": [
            "How Across Works\nOverview\nRoles within Across\nFee Model\nValidating Root Bundles\nDisputing Root Bundles\nDevelopers\nAcross API\nAcross SDK\nContract Addresses\nMainnet (Chain ID: 1)\nArbitrum (Chain ID: 42161)\nOptimism (Chain ID: 10)\nBase (Chain ID: 8453)\nzkSync (Chain ID: 324)\nPolygon (Chain ID: 137)\nSelected Contract Functions\nRunning a Relayer\nIntegrating Across into your application\nComposable Bridging\nDeveloper notes\nMigration from V2 to V3\nADDITIONAL INFO\nSupport Links\nBug Bounty\nAudits",
            "Overview\nRoles within Across\nFee Model\nValidating Root Bundles\nDisputing Root Bundles",
            "Roles within Across\nFee Model\nValidating Root Bundles\nDisputing Root Bundles",
            "Across API\nAcross SDK\nContract Addresses\nMainnet (Chain ID: 1)\nArbitrum (Chain ID: 42161)\nOptimism (Chain ID: 10)\nBase (Chain ID: 8453)\nzkSync (Chain ID: 324)\nPolygon (Chain ID: 137)\nSelected Contract Functions\nRunning a Relayer\nIntegrating Across into your application\nComposable Bridging\nDeveloper notes\nMigration from V2 to V3",
            "Mainnet (Chain ID: 1)\nArbitrum (Chain ID: 42161)\nOptimism (Chain ID: 10)\nBase (Chain ID: 8453)\nzkSync (Chain ID: 324)\nPolygon (Chain ID: 137)",
            "Support Links\nBug Bounty\nAudits",
            "Introduction\nAcross API migration guide\nOverview\nNon-breaking changes\nBreaking changes (mid- to long-term)\nChanges to Across Smart Contracts\nBreaking Change: Across+ (Composable Bridging) \nEvents\nImportant changes for Relayers\nImportant changes for dApp Developers",
            "handleAcrossMessage() -> handleV3AcrossMessage\nFunction parameter `bool fillCompleted` has been removed.",
            "realizedLpFeePct\n The relayer no longer needs to set the \nrealizedLpFeePct\n as a parameter when calling the fill function. LP fees will still be charged to relayers at refund time (i.e. they will receive the inputAmount minus the LP fees) and these fees will still be computed using the formula in the UMIP based on the \ndeposit.quoteTimestamp.\n This is a nice quality of life improvement for relayers who will still need to compute the LP fee for a deposit but can use a much wider margin of error, as this fee will only be important for computing their profitability and they will not be at risk of sending an invalid fill if this fee is off by a small amount.\noutputToken:\n See the section above about how \noutputToken\n must be set if FundsDeposited#outputToken == 0x0. This should be set to the \"equivalent\" token for the destination chain in this case.\nNo partial fills: it is not possible to send partial fills in V3.\nSlow fills: Slow fills will be requested via a new function \nrequestSlowFill\n. Slow fills can only be requested on deposits where the \ninputToken\n and \noutputToken\n are \"equivalent\". Slow fills will pay out the \ninputAmount * realizedLpFeePct\n, which will be set as the slow fill's \nupdatedOutputAmount"
        ],
        "tables": [],
        "code_blocks": [
            {
                "id": "IiFyj7Qx7yhj",
                "code": "type FeesResponse = {\n    // ... other fields\n    capitalFeePct: string;\n    capitalFeeTotal: string;\n    relayGasFeePct: string;\n    relayGasFeeTotal: string;\n    relayFeePct: string; // capitalFeePct + gasFeePct\n    relayFeeTotal: string; // capitalFeeTotal + gasFeeTotal\n    lpFeePct: string;\n}"
            },
            {
                "id": "cbjHyM7Puxz1",
                "code": "const tx = await spokePool.deposit(\n    // ... other args\n    feesResponse.relayFeePct // capitalFeePct + gasFeePct\n)"
            },
            {
                "id": "3FkIhESjSYq0",
                "code": "const totalBridgeFeePct =  relayFeePct + lpFeePct"
            },
            {
                "id": "uOYuu19QpkfW",
                "code": "type FeesResponse = {\n    // ... other fields\n    capitalFeePct: string;\n    capitalFeeTotal: string;\n    relayGasFeePct: string;\n    relayGasFeeTotal: string;\n-   relayFeePct: string; // capitalFeePct + gasFeePct\n+   relayFeePct: string; // capitalFeePct + gasFeePct + lpFeePct\n-   relayFeeTotal: string; // capitalFeeTotal + gasFeeTotal\n+   relayFeeTotal: string; // capitalFeeTotal + gasFeeTotal + lpFeeTotal\n-   lpFeePct: string;\n+   lpFeePct: \"0\";\n}"
            },
            {
                "id": "6TtJcoZZfVTW",
                "code": "type FeesResponse = {\n     // ... other fields\n+    totalRelayFee: { // relayerCapitalFee + relayerGasFee + lpFee\n+        pct: string;\n+        total: string;\n+    };\n+    relayerCapitalFee: {\n+        pct: string;\n+        total: string;\n+    };\n+    relayerGasFee: {\n+        pct: string;\n+        total: string;\n+    };\n+    lpFee: {\n+        pct: string;\n+        total: string;\n+    };\n}"
            },
            {
                "id": "WBTAlCPIyHEY",
                "code": "const tx = await spokePool.deposit(\n    // ... other args\n    feesResponse.totalRelayFee.pct\n)"
            },
            {
                "id": "WrZVJsN5C7dH",
                "code": "function depositV3(\n    address depositor,\n    address recipient,\n    address inputToken,\n    address outputToken,\n    uint256 inputAmount,\n    uint256 outputAmount, // <-- replaces fees\n    uint256 destinationChainId,\n    address exclusiveRelayer,\n    uint32 quoteTimestamp,\n    uint32 fillDeadline,\n    uint32 exclusivityDeadline,\n    bytes calldata message\n) public payable"
            },
            {
                "id": "LMn9flMzFvwT",
                "code": "// Assuming inputToken equals outputToken\nconst outputAmount = inputAmount - feesResponse.totalRelayFee.total\nconst tx = await spokePool.depositV3(\n    // ... other args\n    outputAmount\n)"
            },
            {
                "id": "O5KsT1gT3xr7",
                "code": "type FeesResponse = {\n    // ... other fields\n-    capitalFeePct: string;\n-    capitalFeeTotal: string;\n-    relayGasFeePct: string;\n-    relayGasFeeTotal: string;\n-    relayFeePct: string; // capitalFeePct + gasFeePct\n-    relayFeeTotal: string; // capitalFeeTotal + gasFeeTotal\n-    lpFeePct: string;\n+    totalRelayFee: { // relayerCapitalFee + relayerGasFee + lpFee\n+        pct: string;\n+        total: string;\n+    };\n+    relayerCapitalFee: {\n+        pct: string;\n+        total: string;\n+    };\n+    relayerGasFee: {\n+        pct: string;\n+        total: string;\n+    };\n+    lpFee: {\n+        pct: string;\n+        total: string;\n+    };\n}"
            },
            {
                "id": "NIZ1bfn9gmp4",
                "code": "function handleV3AcrossMessage(\n    address tokenSent,\n    uint256 amount,\n    address relayer,\n    bytes memory message\n) external;"
            },
            {
                "id": "yXEcd0DUJesw",
                "code": "event FundsDeposited(\n    uint256 amount,\n    uint256 originChainId,\n    uint256 indexed destinationChainId,\n    int64 relayerFeePct,\n    uint32 indexed depositId,\n    uint32 quoteTimestamp,\n    address originToken,\n    address recipient,\n    address indexed depositor,\n    bytes message\n)\n\nevent FilledRelay(\n    uint256 amount,\n    uint256 totalFilledAmount,\n    uint256 fillAmount,\n    uint256 repaymentChainId,\n    uint256 indexed originChainId,\n    uint256 destinationChainId,\n    int64 relayerFeePct,\n    int64 realizedLpFeePct,\n    uint32 indexed depositId,\n    address destinationToken,\n    address relayer,\n    address indexed depositor,\n    address recipient,\n    bytes message,\n    RelayExecutionInfo updatableRelayData\n)\n\nstruct RelayExecutionInfo {\n    address recipient;\n    bytes message;\n    int64 relayerFeePct;\n    bool isSlowRelay;\n    int256 payoutAdjustmentPct;\n}"
            },
            {
                "id": "7vjuXkI6xEPh",
                "code": "// Fill type is emitted in the FilledRelay event to assist Dataworker with determining which types of\n// fills to refund (e.g. only fast fills) and whether a fast fill created a sow fill excess.\nenum FillType {\n    FastFill,\n    // Fast fills are normal fills that do not replace a slow fill request.\n    ReplacedSlowFill,\n    // Replaced slow fills are fast fills that replace a slow fill request. This type is used by the Dataworker\n    // to know when to send excess funds from the SpokePool to the HubPool because they can no longer be used\n    // for a slow fill execution.\n    SlowFill\n    // Slow fills are requested via requestSlowFill and executed by executeSlowRelayLeaf after a bundle containing\n    // the slow fill is validated.\n}\n\n struct V3RelayExecutionEventInfo {\n    address updatedRecipient;\n    bytes updatedMessage;\n    uint256 updatedOutputAmount;\n    FillType fillType;\n}\n\nevent V3FundsDeposited(\n    address inputToken,\n    address outputToken,\n    uint256 inputAmount,\n    uint256 outputAmount,\n    uint256 indexed destinationChainId,\n    uint32 indexed depositId,\n    uint32 quoteTimestamp,\n    uint32 fillDeadline,\n    uint32 exclusivityDeadline,\n    address indexed depositor,\n    address recipient,\n    address exclusiveRelayer,\n    bytes message\n);\n\nevent FilledV3Relay(\n    address inputToken,\n    address outputToken,\n    uint256 inputAmount,\n    uint256 outputAmount,\n    uint256 repaymentChainId,\n    uint256 indexed originChainId,\n    uint32 indexed depositId,\n    uint32 fillDeadline,\n    uint32 exclusivityDeadline,\n    address exclusiveRelayer,\n    address indexed relayer,\n    address depositor,\n    address recipient,\n    bytes message,\n    V3RelayExecutionEventInfo relayExecutionInfo\n);"
            },
            {
                "id": "y09rr12kHrmS",
                "code": "/**\n * @notice Fulfill request to bridge cross chain by sending specified output tokens to the recipient.\n * @dev The fee paid to relayers and the system should be captured in the spread between output\n * amount and input amount when adjusted to be denominated in the input token. A relayer on the destination\n * chain will send outputAmount of outputTokens to the recipient and receive inputTokens on a repayment\n * chain of their choice. Therefore, the fee should account for destination fee transaction costs, the\n * relayer's opportunity cost of capital while they wait to be refunded following an optimistic challenge\n * window in the HubPool, and a system fee charged to relayers.\n * @dev The hash of the relayData will be used to uniquely identify the deposit to fill, so\n * modifying any params in it will result in a different hash and a different deposit. The hash will comprise\n * all parameters passed to depositV3() on the origin chain along with that chain's chainId(). This chain's\n * chainId() must therefore match the destinationChainId passed into depositV3.\n * Relayers are only refunded for filling deposits with deposit hashes that map exactly to the one emitted by the\n * origin SpokePool therefore the relayer should not modify any params in relayData.\n * @dev Cannot fill more than once. Partial fills are not supported.\n * @param relayData struct containing all the data needed to identify the deposit to be filled. Should match\n * all the same-named parameters emitted in the origin chain V3FundsDeposited event.\n * - depositor: The account credited with the deposit who can request to \"speed up\" this deposit by modifying\n * the output amount, recipient, and message.\n * - recipient The account receiving funds on this chain. Can be an EOA or a contract. If\n * the output token is the wrapped native token for the chain, then the recipient will receive native token if\n * an EOA or wrapped native token if a contract.\n * - inputToken: The token pulled from the caller's account to initiate the deposit. The equivalent of this\n * token on the repayment chain will be sent as a refund to the caller.\n * - outputToken The token that the caller will send to the recipient on the destination chain. Must be an\n * ERC20.\n * - inputAmount: This amount, less a system fee, will be sent to the caller on their repayment chain of choice as a refund\n * following an optimistic challenge window in the HubPool.\n * - outputAmount: The amount of output tokens that the caller will send to the recipient.\n * - originChainId: The origin chain identifier.\n * - exclusiveRelayer The relayer that will be exclusively allowed to fill this deposit before the\n * exclusivity deadline timestamp.\n * - fillDeadline The deadline for the caller to fill the deposit. After this timestamp,\n * the fill will revert on the destination chain.\n * - exclusivityDeadline: The deadline for the exclusive relayer to fill the deposit. After this\n * timestamp, anyone can fill this deposit.\n * - message The message to send to the recipient if the recipient is a contract that implements a\n * handleV3AcrossMessage() public function\n * @param repaymentChainId Chain of SpokePool where relayer wants to be refunded after the challenge window has\n * passed. Will receive inputAmount of the equivalent token to inputToken on the repayment chain.\n */\nfunction fillV3Relay(V3RelayData calldata relayData, uint256 repaymentChainId)\n\n// This struct represents the data to fully specify a **unique** relay submitted on this chain.\n// This data is hashed with the chainId() and saved by the SpokePool to prevent collisions and protect against\n// replay attacks on other chains. If any portion of this data differs, the relay is considered to be\n// completely distinct.\nstruct V3RelayData {\n    // The address that made the deposit on the origin chain.\n    address depositor;\n    // The recipient address on the destination chain.\n    address recipient;\n    // This is the exclusive relayer who can fill the deposit before the exclusivity deadline.\n    address exclusiveRelayer;\n    // Token that is deposited on origin chain by depositor.\n    address inputToken;\n    // Token that is received on destination chain by recipient.\n    address outputToken;\n    // The amount of input token deposited by depositor.\n    uint256 inputAmount;\n    // The amount of output token to be received by recipient.\n    uint256 outputAmount;\n    // Origin chain id.\n    uint256 originChainId;\n    // The id uniquely identifying this deposit on the origin chain.\n    uint32 depositId;\n    // The timestamp on the destination chain after which this deposit can no longer be filled.\n    uint32 fillDeadline;\n    // The timestamp on the destination chain after which any relayer can fill the deposit.\n    uint32 exclusivityDeadline;\n    // Data that is forwarded to the recipient.\n    bytes message;\n}\n\nstruct V3SlowFill {\n    V3RelayData relayData;\n    uint256 chainId;\n    uint256 updatedOutputAmount;\n}"
            },
            {
                "id": "a9U6puWT51qu",
                "code": "function depositV3(\n    address depositor,\n    address recipient,\n    address inputToken,\n    address outputToken,\n    uint256 inputAmount,\n    uint256 outputAmount,\n    uint256 destinationChainId,\n    address exclusiveRelayer,\n    uint32 quoteTimestamp,\n    uint32 fillDeadline,\n    uint32 exclusivityDeadline,\n    bytes calldata message\n) external payable;\n\n// Old function:\nfunction deposit(\n    address recipient,\n    address originToken,\n    uint256 amount,\n    uint256 destinationChainId,\n    int64 relayerFeePct,\n    uint32 quoteTimestamp,\n    bytes memory message,\n    uint256 maxCount\n) external payable;"
            },
            {
                "id": "rRaA1FkpIQp7",
                "code": "function speedUpV3Deposit(\n    address depositor,\n    uint32 depositId,\n    uint256 updatedOutputAmount,\n    address updatedRecipient,\n    bytes calldata updatedMessage,\n    bytes calldata depositorSignature\n) external;\n\n// Old function:\nfunction speedUpDeposit(\n    address depositor,\n    int64 updatedRelayerFeePct,\n    uint32 depositId,\n    address updatedRecipient,\n    bytes memory updatedMessage,\n    bytes memory depositorSignature\n) external;"
            }
        ],
        "summaries": []
    },
    "https://docs.across.to/developer-docs/additional-info/support-links": {
        "title": "Support Links | Across Docs",
        "headers": [
            "Support Links"
        ],
        "paragraphs": [
            "Across",
            "Twitter",
            "Discord",
            "Medium",
            "Github",
            "Audit report",
            "Last updated 5 months ago"
        ],
        "lists": [
            "How Across Works\nOverview\nRoles within Across\nFee Model\nValidating Root Bundles\nDisputing Root Bundles\nDevelopers\nAcross API\nAcross SDK\nContract Addresses\nMainnet (Chain ID: 1)\nArbitrum (Chain ID: 42161)\nOptimism (Chain ID: 10)\nBase (Chain ID: 8453)\nzkSync (Chain ID: 324)\nPolygon (Chain ID: 137)\nSelected Contract Functions\nRunning a Relayer\nIntegrating Across into your application\nComposable Bridging\nDeveloper notes\nMigration from V2 to V3\nADDITIONAL INFO\nSupport Links\nBug Bounty\nAudits",
            "Overview\nRoles within Across\nFee Model\nValidating Root Bundles\nDisputing Root Bundles",
            "Roles within Across\nFee Model\nValidating Root Bundles\nDisputing Root Bundles",
            "Across API\nAcross SDK\nContract Addresses\nMainnet (Chain ID: 1)\nArbitrum (Chain ID: 42161)\nOptimism (Chain ID: 10)\nBase (Chain ID: 8453)\nzkSync (Chain ID: 324)\nPolygon (Chain ID: 137)\nSelected Contract Functions\nRunning a Relayer\nIntegrating Across into your application\nComposable Bridging\nDeveloper notes\nMigration from V2 to V3",
            "Mainnet (Chain ID: 1)\nArbitrum (Chain ID: 42161)\nOptimism (Chain ID: 10)\nBase (Chain ID: 8453)\nzkSync (Chain ID: 324)\nPolygon (Chain ID: 137)",
            "Support Links\nBug Bounty\nAudits",
            "Across\nTwitter\nDiscord\nMedium\nGithub\nAudit report"
        ],
        "tables": [],
        "code_blocks": [],
        "summaries": []
    },
    "https://docs.across.to/developer-docs/additional-info/bug-bounty": {
        "title": "Bug Bounty | Across Docs",
        "headers": [
            "Bug Bounty",
            "Bounty Program",
            "Submissions",
            "Terms & Conditions"
        ],
        "paragraphs": [
            "Last updated 9 months ago",
            "Security of the platform is our highest priority. All smart contracts and off-chain code (i.e. most of the code within the across-protocol repository) are within scope and are publicly verifiable. Security researchers are eligible for a bug bounty for reporting undiscovered vulnerabilities.",
            "We encourage the community to audit our open source code; we also encourage the responsible disclosure of any issues. The bug bounty program is intended to recognize the value of working with the community of independent security researchers and sets out our definition of good faith in the context of finding and reporting vulnerabilities, as well as what you can expect from us in return.",
            "Across offers substantial rewards for discoveries that can prevent the loss of assets, the freezing of assets, or harm to users.",
            "To be eligible a bounty, a bug must have not been previously known by the Across team or publicly disclosed by anyone. All Across smart contracts and interactions (including bots and front end code) are in scope.",
            "The amount of compensation will vary depending on bug severity. Reward amounts typically correspond to severity in the following manner. The reward currency can be discussed on a case by case basis.",
            "Low",
            "$250",
            "Medium",
            "$1,000",
            "High",
            "$10,000",
            "Critical",
            "up to $1,000,000",
            "Severity is calculated according to the OWASP risk rating model based on Impact and Likelihood.",
            "Please email your submissions to [email¬†protected].",
            "The submission must include clear and concise steps to reproduce the discovered vulnerability. The following layout of the bug bounty report is encouraged:",
            "Description: Describe at a high level the bug with links to problematic code",
            "Attack: Detailed instructions for exploiting the bug",
            "Mitigation: How to resolve the bug",
            "Suggested risk rating: The recommended severity of this bug",
            "The same terms and conditions from the UMA bug bounty program apply here."
        ],
        "lists": [
            "How Across Works\nOverview\nRoles within Across\nFee Model\nValidating Root Bundles\nDisputing Root Bundles\nDevelopers\nAcross API\nAcross SDK\nContract Addresses\nMainnet (Chain ID: 1)\nArbitrum (Chain ID: 42161)\nOptimism (Chain ID: 10)\nBase (Chain ID: 8453)\nzkSync (Chain ID: 324)\nPolygon (Chain ID: 137)\nSelected Contract Functions\nRunning a Relayer\nIntegrating Across into your application\nComposable Bridging\nDeveloper notes\nMigration from V2 to V3\nADDITIONAL INFO\nSupport Links\nBug Bounty\nAudits",
            "Overview\nRoles within Across\nFee Model\nValidating Root Bundles\nDisputing Root Bundles",
            "Roles within Across\nFee Model\nValidating Root Bundles\nDisputing Root Bundles",
            "Across API\nAcross SDK\nContract Addresses\nMainnet (Chain ID: 1)\nArbitrum (Chain ID: 42161)\nOptimism (Chain ID: 10)\nBase (Chain ID: 8453)\nzkSync (Chain ID: 324)\nPolygon (Chain ID: 137)\nSelected Contract Functions\nRunning a Relayer\nIntegrating Across into your application\nComposable Bridging\nDeveloper notes\nMigration from V2 to V3",
            "Mainnet (Chain ID: 1)\nArbitrum (Chain ID: 42161)\nOptimism (Chain ID: 10)\nBase (Chain ID: 8453)\nzkSync (Chain ID: 324)\nPolygon (Chain ID: 137)",
            "Support Links\nBug Bounty\nAudits",
            "Bounty Program\nSubmissions\nTerms & Conditions",
            "Description: Describe at a high level the bug with links to problematic code\nAttack: Detailed instructions for exploiting the bug\nMitigation: How to resolve the bug\nSuggested risk rating: The recommended severity of this bug"
        ],
        "tables": [
            [
                [
                    "Severity",
                    "Reward"
                ],
                [
                    "Low",
                    "$250"
                ],
                [
                    "Medium",
                    "$1,000"
                ],
                [
                    "High",
                    "$10,000"
                ],
                [
                    "Critical",
                    "up to $1,000,000"
                ]
            ]
        ],
        "code_blocks": [],
        "summaries": []
    },
    "https://docs.across.to/developer-docs/additional-info/audits": {
        "title": "Audits | Across Docs",
        "headers": [
            "Audits"
        ],
        "paragraphs": [
            "Across Token and Token Distributor Audit",
            "Across V2 Audit",
            "UMA's Continuous Audit (Optimistic Oracle)",
            "UMA Audit ‚Äì L2 Bridges",
            "UMA Audit ‚Äì Phase 4",
            "UMA Audit ‚Äì Phase 6",
            "Last updated 1 year ago"
        ],
        "lists": [
            "How Across Works\nOverview\nRoles within Across\nFee Model\nValidating Root Bundles\nDisputing Root Bundles\nDevelopers\nAcross API\nAcross SDK\nContract Addresses\nMainnet (Chain ID: 1)\nArbitrum (Chain ID: 42161)\nOptimism (Chain ID: 10)\nBase (Chain ID: 8453)\nzkSync (Chain ID: 324)\nPolygon (Chain ID: 137)\nSelected Contract Functions\nRunning a Relayer\nIntegrating Across into your application\nComposable Bridging\nDeveloper notes\nMigration from V2 to V3\nADDITIONAL INFO\nSupport Links\nBug Bounty\nAudits",
            "Overview\nRoles within Across\nFee Model\nValidating Root Bundles\nDisputing Root Bundles",
            "Roles within Across\nFee Model\nValidating Root Bundles\nDisputing Root Bundles",
            "Across API\nAcross SDK\nContract Addresses\nMainnet (Chain ID: 1)\nArbitrum (Chain ID: 42161)\nOptimism (Chain ID: 10)\nBase (Chain ID: 8453)\nzkSync (Chain ID: 324)\nPolygon (Chain ID: 137)\nSelected Contract Functions\nRunning a Relayer\nIntegrating Across into your application\nComposable Bridging\nDeveloper notes\nMigration from V2 to V3",
            "Mainnet (Chain ID: 1)\nArbitrum (Chain ID: 42161)\nOptimism (Chain ID: 10)\nBase (Chain ID: 8453)\nzkSync (Chain ID: 324)\nPolygon (Chain ID: 137)",
            "Support Links\nBug Bounty\nAudits",
            "Across Token and Token Distributor Audit\nAcross V2 Audit\nUMA's Continuous Audit (Optimistic Oracle)\nUMA Audit ‚Äì L2 Bridges\nUMA Audit ‚Äì Phase 4\nUMA Audit ‚Äì Phase 6"
        ],
        "tables": [],
        "code_blocks": [],
        "summaries": []
    },
    "https://www.gitbook.com/?utm_source=content&utm_medium=trademark&utm_campaign=hBVFLntFXCM0TMmhxIGU": {
        "title": "GitBook",
        "headers": [
            "Product documentationyour users will love",
            "Publish unbeatable documentation",
            "Better internal docs",
            "Collaborate on docs like you collaborate on code",
            "Smarter, AI-powered documentation",
            "Control access to your published docs",
            "Integrate with your stack",
            "Our customers love GitBook!",
            "Get started for free",
            "Get started for free",
            "Get started for free"
        ],
        "paragraphs": [
            "Product",
            "Features",
            "Resources",
            "Pricing",
            "",
            "",
            "",
            "We're hiring!",
            "Forget building your own custom docs platform. With GitBook you get beautiful documentation for your users, and a branch-based Git workflow for your team.",
            "Sign up with GitHub",
            "Home Hero GitHub CTA",
            "Sign up with GitHub",
            "sign_up_github",
            "Sign up with GitHub",
            "Home Hero GitHub CTA",
            "Sign up with GitHub",
            "sign_up_github",
            "Sign up with GitHub",
            "Home Hero GitHub CTA",
            "Sign up with GitHub",
            "sign_up_github",
            "Start for free",
            "Home Hero CTA",
            "Start for free",
            "sign_up",
            "Start for free",
            "Home Hero CTA",
            "Start for free",
            "sign_up",
            "Start for free",
            "Home Hero CTA",
            "Start for free",
            "sign_up",
            "Published site",
            "GitBook editor",
            "Published site",
            "GitBook editor",
            "Public docs",
            "Effortlessly migrate your product docs to GitBook, customize them to match your brand, then publish them to the world √¢¬Ä¬î¬†or just a selected group, if you prefer. Then keep them updated with built-in content insights.",
            "Discover documentation",
            "Home Public Docs Block",
            "Discover Documentation",
            "open_public_docs_website",
            "Discover documentation",
            "Home Public Docs Block",
            "Discover Documentation",
            "open_public_docs_website",
            "Discover documentation",
            "Home Public Docs Block",
            "Discover Documentation",
            "open_public_docs_website",
            "Internal docs",
            "Find the perfect new home for your organization√¢¬Ä¬ôs code docs, technical wikis, product plans, API documentation and more. GitBook is flexible, and uses a Git-like branching workflow your team will love.",
            "Learn more",
            "Home Internal Docs Block",
            "Learn More",
            "open_internal_docs_website",
            "Learn more",
            "Home Internal Docs Block",
            "Learn More",
            "open_internal_docs_website",
            "Learn more",
            "Home Internal Docs Block",
            "Learn More",
            "open_internal_docs_website",
            "Git Sync",
            "Sync your docs with a GitHub or GitLab repository and everyone can contribute to your docs, wherever they prefer to work. So your technical writers can use WYSIWYG editor, while engineers add to your docs directly in Git. And everything stays in sync, with feedback and reviews to guarantee quality.",
            "Discover Git Sync",
            "Home GitSync Block",
            "Tell me more",
            "open_gitsync_website",
            "Discover Git Sync",
            "Home GitSync Block",
            "Tell me more",
            "open_gitsync_website",
            "Discover Git Sync",
            "Home GitSync Block",
            "Tell me more",
            "open_gitsync_website",
            "GitBook AI",
            "Improve your writing with a click.¬†GitBook AI can simplify, shorten, or translate any text you want √¢¬Ä¬î¬†or even just write a first draft for you. And because GitBook AI is trained on your docs, you can ask it a question and get the answer you need instantly. And so can your users.",
            "Explore GitBook AI",
            "Home GitBook AI Block",
            "Explore GitBook AI",
            "open_gitbook_ai_website",
            "Explore GitBook AI",
            "Home GitBook AI Block",
            "Explore GitBook AI",
            "open_gitbook_ai_website",
            "Explore GitBook AI",
            "Home GitBook AI Block",
            "Explore GitBook AI",
            "open_gitbook_ai_website",
            "Visitor authentication",
            "Choose who can access your documentation. With visitor authentication, you can keep sensitive information away from competitors and hackers. So only your chosen customers, team members or authorized users can view your docs.",
            "Find out more",
            "Home VA Block",
            "Find out more",
            "open_va_website",
            "Find out more",
            "Home VA Block",
            "Find out more",
            "open_va_website",
            "Find out more",
            "Home VA Block",
            "Find out more",
            "open_va_website",
            "Integrations",
            "Install one of our verified integrations, or build your own with our API. Because a great knowledge management system should work with everything you use on a daily basis.",
            "See our integrations",
            "Home Integrations Block",
            "See our integrations",
            "open_integrations_website",
            "See our integrations",
            "Home Integrations Block",
            "See our integrations",
            "open_integrations_website",
            "See our integrations",
            "Home Integrations Block",
            "See our integrations",
            "open_integrations_website",
            "\"GitBook is uniquely designed to serve both as an internal wiki and as a source for easily editable public docs √¢¬Ä¬î all backed by change requests, custom domain configuration, and git. This combination really differentiates the tool and has been super helpful to our team.\"",
            "Billy Daly",
            "\"GitBook is uniquely designed to serve both as an internal wiki and as a source for easily editable public docs √¢¬Ä¬î all backed by change requests, custom domain configuration, and git. This combination really differentiates the tool and has been super helpful to our team.\"",
            "Billy Daly",
            "\"GitBook is uniquely designed to serve both as an internal wiki and as a source for easily editable public docs √¢¬Ä¬î all backed by change requests, custom domain configuration, and git. This combination really differentiates the tool and has been super helpful to our team.\"",
            "Billy Daly",
            "Eli√É¬©cer Hern√É¬°ndez",
            "We use Gitbook at our startup to write useful and easy-to-digest documentation. It is the only platform that provides so much flexibility for this.",
            "Eli√É¬©cer Hern√É¬°ndez",
            "We use Gitbook at our startup to write useful and easy-to-digest documentation. It is the only platform that provides so much flexibility for this.",
            "Eli√É¬©cer Hern√É¬°ndez",
            "We use Gitbook at our startup to write useful and easy-to-digest documentation. It is the only platform that provides so much flexibility for this.",
            "Austin Hamrick",
            "GitBook is a great source for handbooks, manuals, and other documents for online resources.",
            "Austin Hamrick",
            "GitBook is a great source for handbooks, manuals, and other documents for online resources.",
            "Austin Hamrick",
            "GitBook is a great source for handbooks, manuals, and other documents for online resources.",
            "Shubhendu Shubham",
            "Now @GitBook supports AI based summaries and search from your documentation. One of the best documentation tools for developers & open source enthusiasts.",
            "Shubhendu Shubham",
            "Now @GitBook supports AI based summaries and search from your documentation. One of the best documentation tools for developers & open source enthusiasts.",
            "Shubhendu Shubham",
            "Now @GitBook supports AI based summaries and search from your documentation. One of the best documentation tools for developers & open source enthusiasts.",
            "Lane Fox",
            "I build software tools and use GitBook for documentation. It's amazing, I recommend it to all of my colleagues doing similar work. I honestly don't know what I would do without it.",
            "Lane Fox",
            "I build software tools and use GitBook for documentation. It's amazing, I recommend it to all of my colleagues doing similar work. I honestly don't know what I would do without it.",
            "Lane Fox",
            "I build software tools and use GitBook for documentation. It's amazing, I recommend it to all of my colleagues doing similar work. I honestly don't know what I would do without it.",
            "Sewell Stephens",
            "I would definately recommend Gitbook. I've used it for a while and it works great.",
            "Sewell Stephens",
            "I would definately recommend Gitbook. I've used it for a while and it works great.",
            "Sewell Stephens",
            "I would definately recommend Gitbook. I've used it for a while and it works great.",
            "Elme Dela Rosa",
            "My portfolio is on GitBook! Love how versatile and flexible this app is. highly recommended.",
            "Elme Dela Rosa",
            "My portfolio is on GitBook! Love how versatile and flexible this app is. highly recommended.",
            "Elme Dela Rosa",
            "My portfolio is on GitBook! Love how versatile and flexible this app is. highly recommended.",
            "Vlad A. Ionescu",
            "We switched to @GitBook (git-powered documentation hosting) a while back and so far we're really, really happy with it. More people need to know about this amazing service!",
            "Vlad A. Ionescu",
            "We switched to @GitBook (git-powered documentation hosting) a while back and so far we're really, really happy with it. More people need to know about this amazing service!",
            "Vlad A. Ionescu",
            "We switched to @GitBook (git-powered documentation hosting) a while back and so far we're really, really happy with it. More people need to know about this amazing service!",
            "Illia Berestovskyi",
            "I enjoy the product. GitBook became the one-place tool for all documentation of our product.",
            "Illia Berestovskyi",
            "I enjoy the product. GitBook became the one-place tool for all documentation of our product.",
            "Illia Berestovskyi",
            "I enjoy the product. GitBook became the one-place tool for all documentation of our product.",
            "Rob Hussey",
            "I use GitBook in all my apps for self-serve knowledge base/help docs.",
            "Rob Hussey",
            "I use GitBook in all my apps for self-serve knowledge base/help docs.",
            "Rob Hussey",
            "I use GitBook in all my apps for self-serve knowledge base/help docs.",
            "Noj Vek",
            "Was comparing @GitBook with @NotionHQ, I think GitBook wins hands down in its offering. Its focused, the UI is clean, fast and very user friendly. (Personal Notes | KnowledgeBase | Product Docs). Makes sense that it has 500k users. Love the product.",
            "Noj Vek",
            "Was comparing @GitBook with @NotionHQ, I think GitBook wins hands down in its offering. Its focused, the UI is clean, fast and very user friendly. (Personal Notes | KnowledgeBase | Product Docs). Makes sense that it has 500k users. Love the product.",
            "Noj Vek",
            "Was comparing @GitBook with @NotionHQ, I think GitBook wins hands down in its offering. Its focused, the UI is clean, fast and very user friendly. (Personal Notes | KnowledgeBase | Product Docs). Makes sense that it has 500k users. Love the product.",
            "Play around with GitBook and set up your docs for free.  Add your team and pay when you√¢¬Ä¬ôre ready.",
            "Sign up with GitHub",
            "Footer CTA",
            "Sign up with GitHub",
            "sign_up_github",
            "Start for free",
            "Footer CTA",
            "Start for free",
            "sign_up",
            "Play around with GitBook and set up your docs for free.  Add your team and pay when you√¢¬Ä¬ôre ready.",
            "Sign up with GitHub",
            "Footer CTA",
            "Sign up with GitHub",
            "sign_up_github",
            "Start for free",
            "Footer CTA",
            "Start for free",
            "sign_up",
            "Play around with GitBook and set up your docs for free.  Add your team and pay when you√¢¬Ä¬ôre ready.",
            "Sign up with GitHub",
            "Footer CTA",
            "Sign up with GitHub",
            "sign_up_github",
            "Start for free",
            "Footer CTA",
            "Start for free",
            "sign_up",
            "Public docs",
            "",
            "",
            "",
            "API docs",
            "",
            "",
            "",
            "Internal docs",
            "",
            "",
            "",
            "Enterprise",
            "",
            "",
            "",
            "Open source",
            "",
            "",
            "",
            "Product tour",
            "",
            "",
            "",
            "Pricing",
            "",
            "",
            "",
            "Visitor authentication",
            "",
            "",
            "",
            "Git Sync",
            "",
            "",
            "",
            "GitBook AI",
            "",
            "",
            "",
            "Integrations",
            "",
            "",
            "",
            "Docs",
            "",
            "",
            "",
            "Blog",
            "",
            "",
            "",
            "Videos",
            "",
            "",
            "",
            "Events",
            "",
            "",
            "",
            "Changelog",
            "",
            "",
            "",
            "Security and compliance",
            "",
            "",
            "",
            "Newsletter",
            "",
            "",
            "",
            "About",
            "",
            "",
            "",
            "Careers",
            "",
            "",
            "",
            "Contact and support",
            "",
            "",
            "",
            "√Ç¬© 2024 Copyright GitBook INC. 440 N Barranca Ave #7171, Covina, CA 91723, USA. EIN: 320502699",
            "Public docs",
            "",
            "",
            "",
            "API docs",
            "",
            "",
            "",
            "Internal docs",
            "",
            "",
            "",
            "Enterprise",
            "",
            "",
            "",
            "Open source",
            "",
            "",
            "",
            "Product tour",
            "",
            "",
            "",
            "Pricing",
            "",
            "",
            "",
            "Visitor authentication",
            "",
            "",
            "",
            "Git Sync",
            "",
            "",
            "",
            "GitBook AI",
            "",
            "",
            "",
            "Integrations",
            "",
            "",
            "",
            "Docs",
            "",
            "",
            "",
            "Blog",
            "",
            "",
            "",
            "Videos",
            "",
            "",
            "",
            "Events",
            "",
            "",
            "",
            "Changelog",
            "",
            "",
            "",
            "Security and compliance",
            "",
            "",
            "",
            "Newsletter",
            "",
            "",
            "",
            "About",
            "",
            "",
            "",
            "Careers",
            "",
            "",
            "",
            "Contact and support",
            "",
            "",
            "",
            "√Ç¬© 2024 Copyright GitBook INC. 440 N Barranca Ave #7171, Covina, CA 91723, USA. EIN: 320502699",
            "Public docs",
            "",
            "",
            "",
            "API docs",
            "",
            "",
            "",
            "Internal docs",
            "",
            "",
            "",
            "Enterprise",
            "",
            "",
            "",
            "Open source",
            "",
            "",
            "",
            "Product tour",
            "",
            "",
            "",
            "Pricing",
            "",
            "",
            "",
            "Visitor authentication",
            "",
            "",
            "",
            "Git Sync",
            "",
            "",
            "",
            "GitBook AI",
            "",
            "",
            "",
            "Integrations",
            "",
            "",
            "",
            "Docs",
            "",
            "",
            "",
            "Blog",
            "",
            "",
            "",
            "Videos",
            "",
            "",
            "",
            "Events",
            "",
            "",
            "",
            "Changelog",
            "",
            "",
            "",
            "Security and compliance",
            "",
            "",
            "",
            "Newsletter",
            "",
            "",
            "",
            "About",
            "",
            "",
            "",
            "Careers",
            "",
            "",
            "",
            "Contact and support",
            "",
            "",
            "",
            "√Ç¬© 2024 Copyright GitBook INC. 440 N Barranca Ave #7171, Covina, CA 91723, USA. EIN: 320502699"
        ],
        "lists": [
            "",
            "",
            "",
            "",
            "",
            "",
            "",
            "",
            ""
        ],
        "tables": [],
        "code_blocks": [],
        "summaries": []
    }
}